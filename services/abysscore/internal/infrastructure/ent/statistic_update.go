// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/predicate"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/statistic"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// StatisticUpdate is the builder for updating Statistic entities.
type StatisticUpdate struct {
	config
	hooks    []Hook
	mutation *StatisticMutation
}

// Where appends a list predicates to the StatisticUpdate builder.
func (su *StatisticUpdate) Where(ps ...predicate.Statistic) *StatisticUpdate {
	su.mutation.Where(ps...)
	return su
}

// SetType sets the "type" field.
func (su *StatisticUpdate) SetType(s statistic.Type) *StatisticUpdate {
	su.mutation.SetType(s)
	return su
}

// SetNillableType sets the "type" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableType(s *statistic.Type) *StatisticUpdate {
	if s != nil {
		su.SetType(*s)
	}
	return su
}

// SetPeriod sets the "period" field.
func (su *StatisticUpdate) SetPeriod(i int) *StatisticUpdate {
	su.mutation.ResetPeriod()
	su.mutation.SetPeriod(i)
	return su
}

// SetNillablePeriod sets the "period" field if the given value is not nil.
func (su *StatisticUpdate) SetNillablePeriod(i *int) *StatisticUpdate {
	if i != nil {
		su.SetPeriod(*i)
	}
	return su
}

// AddPeriod adds i to the "period" field.
func (su *StatisticUpdate) AddPeriod(i int) *StatisticUpdate {
	su.mutation.AddPeriod(i)
	return su
}

// SetXp sets the "xp" field.
func (su *StatisticUpdate) SetXp(i int) *StatisticUpdate {
	su.mutation.ResetXp()
	su.mutation.SetXp(i)
	return su
}

// SetNillableXp sets the "xp" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableXp(i *int) *StatisticUpdate {
	if i != nil {
		su.SetXp(*i)
	}
	return su
}

// AddXp adds i to the "xp" field.
func (su *StatisticUpdate) AddXp(i int) *StatisticUpdate {
	su.mutation.AddXp(i)
	return su
}

// SetMatchCount sets the "match_count" field.
func (su *StatisticUpdate) SetMatchCount(i int) *StatisticUpdate {
	su.mutation.ResetMatchCount()
	su.mutation.SetMatchCount(i)
	return su
}

// SetNillableMatchCount sets the "match_count" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableMatchCount(i *int) *StatisticUpdate {
	if i != nil {
		su.SetMatchCount(*i)
	}
	return su
}

// AddMatchCount adds i to the "match_count" field.
func (su *StatisticUpdate) AddMatchCount(i int) *StatisticUpdate {
	su.mutation.AddMatchCount(i)
	return su
}

// SetWinsCount sets the "wins_count" field.
func (su *StatisticUpdate) SetWinsCount(i int) *StatisticUpdate {
	su.mutation.ResetWinsCount()
	su.mutation.SetWinsCount(i)
	return su
}

// SetNillableWinsCount sets the "wins_count" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableWinsCount(i *int) *StatisticUpdate {
	if i != nil {
		su.SetWinsCount(*i)
	}
	return su
}

// AddWinsCount adds i to the "wins_count" field.
func (su *StatisticUpdate) AddWinsCount(i int) *StatisticUpdate {
	su.mutation.AddWinsCount(i)
	return su
}

// SetLosesCount sets the "loses_count" field.
func (su *StatisticUpdate) SetLosesCount(i int) *StatisticUpdate {
	su.mutation.ResetLosesCount()
	su.mutation.SetLosesCount(i)
	return su
}

// SetNillableLosesCount sets the "loses_count" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableLosesCount(i *int) *StatisticUpdate {
	if i != nil {
		su.SetLosesCount(*i)
	}
	return su
}

// AddLosesCount adds i to the "loses_count" field.
func (su *StatisticUpdate) AddLosesCount(i int) *StatisticUpdate {
	su.mutation.AddLosesCount(i)
	return su
}

// SetDrawsCount sets the "draws_count" field.
func (su *StatisticUpdate) SetDrawsCount(i int) *StatisticUpdate {
	su.mutation.ResetDrawsCount()
	su.mutation.SetDrawsCount(i)
	return su
}

// SetNillableDrawsCount sets the "draws_count" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableDrawsCount(i *int) *StatisticUpdate {
	if i != nil {
		su.SetDrawsCount(*i)
	}
	return su
}

// AddDrawsCount adds i to the "draws_count" field.
func (su *StatisticUpdate) AddDrawsCount(i int) *StatisticUpdate {
	su.mutation.AddDrawsCount(i)
	return su
}

// SetResultTime sets the "result_time" field.
func (su *StatisticUpdate) SetResultTime(i int) *StatisticUpdate {
	su.mutation.ResetResultTime()
	su.mutation.SetResultTime(i)
	return su
}

// SetNillableResultTime sets the "result_time" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableResultTime(i *int) *StatisticUpdate {
	if i != nil {
		su.SetResultTime(*i)
	}
	return su
}

// AddResultTime adds i to the "result_time" field.
func (su *StatisticUpdate) AddResultTime(i int) *StatisticUpdate {
	su.mutation.AddResultTime(i)
	return su
}

// SetRetryTime sets the "retry_time" field.
func (su *StatisticUpdate) SetRetryTime(i int) *StatisticUpdate {
	su.mutation.ResetRetryTime()
	su.mutation.SetRetryTime(i)
	return su
}

// SetNillableRetryTime sets the "retry_time" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableRetryTime(i *int) *StatisticUpdate {
	if i != nil {
		su.SetRetryTime(*i)
	}
	return su
}

// AddRetryTime adds i to the "retry_time" field.
func (su *StatisticUpdate) AddRetryTime(i int) *StatisticUpdate {
	su.mutation.AddRetryTime(i)
	return su
}

// SetRetryCount sets the "retry_count" field.
func (su *StatisticUpdate) SetRetryCount(i int) *StatisticUpdate {
	su.mutation.ResetRetryCount()
	su.mutation.SetRetryCount(i)
	return su
}

// SetNillableRetryCount sets the "retry_count" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableRetryCount(i *int) *StatisticUpdate {
	if i != nil {
		su.SetRetryCount(*i)
	}
	return su
}

// AddRetryCount adds i to the "retry_count" field.
func (su *StatisticUpdate) AddRetryCount(i int) *StatisticUpdate {
	su.mutation.AddRetryCount(i)
	return su
}

// SetBestResultTime sets the "best_result_time" field.
func (su *StatisticUpdate) SetBestResultTime(i int) *StatisticUpdate {
	su.mutation.ResetBestResultTime()
	su.mutation.SetBestResultTime(i)
	return su
}

// SetNillableBestResultTime sets the "best_result_time" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableBestResultTime(i *int) *StatisticUpdate {
	if i != nil {
		su.SetBestResultTime(*i)
	}
	return su
}

// AddBestResultTime adds i to the "best_result_time" field.
func (su *StatisticUpdate) AddBestResultTime(i int) *StatisticUpdate {
	su.mutation.AddBestResultTime(i)
	return su
}

// SetBestRetryCount sets the "best_retry_count" field.
func (su *StatisticUpdate) SetBestRetryCount(i int) *StatisticUpdate {
	su.mutation.ResetBestRetryCount()
	su.mutation.SetBestRetryCount(i)
	return su
}

// SetNillableBestRetryCount sets the "best_retry_count" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableBestRetryCount(i *int) *StatisticUpdate {
	if i != nil {
		su.SetBestRetryCount(*i)
	}
	return su
}

// AddBestRetryCount adds i to the "best_retry_count" field.
func (su *StatisticUpdate) AddBestRetryCount(i int) *StatisticUpdate {
	su.mutation.AddBestRetryCount(i)
	return su
}

// SetBestMatchTime sets the "best_match_time" field.
func (su *StatisticUpdate) SetBestMatchTime(i int) *StatisticUpdate {
	su.mutation.ResetBestMatchTime()
	su.mutation.SetBestMatchTime(i)
	return su
}

// SetNillableBestMatchTime sets the "best_match_time" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableBestMatchTime(i *int) *StatisticUpdate {
	if i != nil {
		su.SetBestMatchTime(*i)
	}
	return su
}

// AddBestMatchTime adds i to the "best_match_time" field.
func (su *StatisticUpdate) AddBestMatchTime(i int) *StatisticUpdate {
	su.mutation.AddBestMatchTime(i)
	return su
}

// SetWorstResultTime sets the "worst_result_time" field.
func (su *StatisticUpdate) SetWorstResultTime(i int) *StatisticUpdate {
	su.mutation.ResetWorstResultTime()
	su.mutation.SetWorstResultTime(i)
	return su
}

// SetNillableWorstResultTime sets the "worst_result_time" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableWorstResultTime(i *int) *StatisticUpdate {
	if i != nil {
		su.SetWorstResultTime(*i)
	}
	return su
}

// AddWorstResultTime adds i to the "worst_result_time" field.
func (su *StatisticUpdate) AddWorstResultTime(i int) *StatisticUpdate {
	su.mutation.AddWorstResultTime(i)
	return su
}

// SetWorstRetryCount sets the "worst_retry_count" field.
func (su *StatisticUpdate) SetWorstRetryCount(i int) *StatisticUpdate {
	su.mutation.ResetWorstRetryCount()
	su.mutation.SetWorstRetryCount(i)
	return su
}

// SetNillableWorstRetryCount sets the "worst_retry_count" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableWorstRetryCount(i *int) *StatisticUpdate {
	if i != nil {
		su.SetWorstRetryCount(*i)
	}
	return su
}

// AddWorstRetryCount adds i to the "worst_retry_count" field.
func (su *StatisticUpdate) AddWorstRetryCount(i int) *StatisticUpdate {
	su.mutation.AddWorstRetryCount(i)
	return su
}

// SetWorstMatchTime sets the "worst_match_time" field.
func (su *StatisticUpdate) SetWorstMatchTime(i int) *StatisticUpdate {
	su.mutation.ResetWorstMatchTime()
	su.mutation.SetWorstMatchTime(i)
	return su
}

// SetNillableWorstMatchTime sets the "worst_match_time" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableWorstMatchTime(i *int) *StatisticUpdate {
	if i != nil {
		su.SetWorstMatchTime(*i)
	}
	return su
}

// AddWorstMatchTime adds i to the "worst_match_time" field.
func (su *StatisticUpdate) AddWorstMatchTime(i int) *StatisticUpdate {
	su.mutation.AddWorstMatchTime(i)
	return su
}

// SetMaxWinStreak sets the "max_win_streak" field.
func (su *StatisticUpdate) SetMaxWinStreak(i int) *StatisticUpdate {
	su.mutation.ResetMaxWinStreak()
	su.mutation.SetMaxWinStreak(i)
	return su
}

// SetNillableMaxWinStreak sets the "max_win_streak" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableMaxWinStreak(i *int) *StatisticUpdate {
	if i != nil {
		su.SetMaxWinStreak(*i)
	}
	return su
}

// AddMaxWinStreak adds i to the "max_win_streak" field.
func (su *StatisticUpdate) AddMaxWinStreak(i int) *StatisticUpdate {
	su.mutation.AddMaxWinStreak(i)
	return su
}

// SetMaxLoseStreak sets the "max_lose_streak" field.
func (su *StatisticUpdate) SetMaxLoseStreak(i int) *StatisticUpdate {
	su.mutation.ResetMaxLoseStreak()
	su.mutation.SetMaxLoseStreak(i)
	return su
}

// SetNillableMaxLoseStreak sets the "max_lose_streak" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableMaxLoseStreak(i *int) *StatisticUpdate {
	if i != nil {
		su.SetMaxLoseStreak(*i)
	}
	return su
}

// AddMaxLoseStreak adds i to the "max_lose_streak" field.
func (su *StatisticUpdate) AddMaxLoseStreak(i int) *StatisticUpdate {
	su.mutation.AddMaxLoseStreak(i)
	return su
}

// SetMaxLoginStreak sets the "max_login_streak" field.
func (su *StatisticUpdate) SetMaxLoginStreak(i int) *StatisticUpdate {
	su.mutation.ResetMaxLoginStreak()
	su.mutation.SetMaxLoginStreak(i)
	return su
}

// SetNillableMaxLoginStreak sets the "max_login_streak" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableMaxLoginStreak(i *int) *StatisticUpdate {
	if i != nil {
		su.SetMaxLoginStreak(*i)
	}
	return su
}

// AddMaxLoginStreak adds i to the "max_login_streak" field.
func (su *StatisticUpdate) AddMaxLoginStreak(i int) *StatisticUpdate {
	su.mutation.AddMaxLoginStreak(i)
	return su
}

// SetSearchScore sets the "search_score" field.
func (su *StatisticUpdate) SetSearchScore(i int) *StatisticUpdate {
	su.mutation.ResetSearchScore()
	su.mutation.SetSearchScore(i)
	return su
}

// SetNillableSearchScore sets the "search_score" field if the given value is not nil.
func (su *StatisticUpdate) SetNillableSearchScore(i *int) *StatisticUpdate {
	if i != nil {
		su.SetSearchScore(*i)
	}
	return su
}

// AddSearchScore adds i to the "search_score" field.
func (su *StatisticUpdate) AddSearchScore(i int) *StatisticUpdate {
	su.mutation.AddSearchScore(i)
	return su
}

// Mutation returns the StatisticMutation object of the builder.
func (su *StatisticUpdate) Mutation() *StatisticMutation {
	return su.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (su *StatisticUpdate) Save(ctx context.Context) (int, error) {
	return withHooks(ctx, su.sqlSave, su.mutation, su.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (su *StatisticUpdate) SaveX(ctx context.Context) int {
	affected, err := su.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (su *StatisticUpdate) Exec(ctx context.Context) error {
	_, err := su.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (su *StatisticUpdate) ExecX(ctx context.Context) {
	if err := su.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (su *StatisticUpdate) check() error {
	if v, ok := su.mutation.GetType(); ok {
		if err := statistic.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Statistic.type": %w`, err)}
		}
	}
	if v, ok := su.mutation.Period(); ok {
		if err := statistic.PeriodValidator(v); err != nil {
			return &ValidationError{Name: "period", err: fmt.Errorf(`ent: validator failed for field "Statistic.period": %w`, err)}
		}
	}
	if v, ok := su.mutation.Xp(); ok {
		if err := statistic.XpValidator(v); err != nil {
			return &ValidationError{Name: "xp", err: fmt.Errorf(`ent: validator failed for field "Statistic.xp": %w`, err)}
		}
	}
	if v, ok := su.mutation.MatchCount(); ok {
		if err := statistic.MatchCountValidator(v); err != nil {
			return &ValidationError{Name: "match_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.match_count": %w`, err)}
		}
	}
	if v, ok := su.mutation.WinsCount(); ok {
		if err := statistic.WinsCountValidator(v); err != nil {
			return &ValidationError{Name: "wins_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.wins_count": %w`, err)}
		}
	}
	if v, ok := su.mutation.LosesCount(); ok {
		if err := statistic.LosesCountValidator(v); err != nil {
			return &ValidationError{Name: "loses_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.loses_count": %w`, err)}
		}
	}
	if v, ok := su.mutation.DrawsCount(); ok {
		if err := statistic.DrawsCountValidator(v); err != nil {
			return &ValidationError{Name: "draws_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.draws_count": %w`, err)}
		}
	}
	if v, ok := su.mutation.ResultTime(); ok {
		if err := statistic.ResultTimeValidator(v); err != nil {
			return &ValidationError{Name: "result_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.result_time": %w`, err)}
		}
	}
	if v, ok := su.mutation.RetryTime(); ok {
		if err := statistic.RetryTimeValidator(v); err != nil {
			return &ValidationError{Name: "retry_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.retry_time": %w`, err)}
		}
	}
	if v, ok := su.mutation.RetryCount(); ok {
		if err := statistic.RetryCountValidator(v); err != nil {
			return &ValidationError{Name: "retry_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.retry_count": %w`, err)}
		}
	}
	if v, ok := su.mutation.BestResultTime(); ok {
		if err := statistic.BestResultTimeValidator(v); err != nil {
			return &ValidationError{Name: "best_result_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.best_result_time": %w`, err)}
		}
	}
	if v, ok := su.mutation.BestRetryCount(); ok {
		if err := statistic.BestRetryCountValidator(v); err != nil {
			return &ValidationError{Name: "best_retry_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.best_retry_count": %w`, err)}
		}
	}
	if v, ok := su.mutation.BestMatchTime(); ok {
		if err := statistic.BestMatchTimeValidator(v); err != nil {
			return &ValidationError{Name: "best_match_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.best_match_time": %w`, err)}
		}
	}
	if v, ok := su.mutation.WorstResultTime(); ok {
		if err := statistic.WorstResultTimeValidator(v); err != nil {
			return &ValidationError{Name: "worst_result_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.worst_result_time": %w`, err)}
		}
	}
	if v, ok := su.mutation.WorstRetryCount(); ok {
		if err := statistic.WorstRetryCountValidator(v); err != nil {
			return &ValidationError{Name: "worst_retry_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.worst_retry_count": %w`, err)}
		}
	}
	if v, ok := su.mutation.WorstMatchTime(); ok {
		if err := statistic.WorstMatchTimeValidator(v); err != nil {
			return &ValidationError{Name: "worst_match_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.worst_match_time": %w`, err)}
		}
	}
	if v, ok := su.mutation.MaxWinStreak(); ok {
		if err := statistic.MaxWinStreakValidator(v); err != nil {
			return &ValidationError{Name: "max_win_streak", err: fmt.Errorf(`ent: validator failed for field "Statistic.max_win_streak": %w`, err)}
		}
	}
	if v, ok := su.mutation.MaxLoseStreak(); ok {
		if err := statistic.MaxLoseStreakValidator(v); err != nil {
			return &ValidationError{Name: "max_lose_streak", err: fmt.Errorf(`ent: validator failed for field "Statistic.max_lose_streak": %w`, err)}
		}
	}
	if v, ok := su.mutation.MaxLoginStreak(); ok {
		if err := statistic.MaxLoginStreakValidator(v); err != nil {
			return &ValidationError{Name: "max_login_streak", err: fmt.Errorf(`ent: validator failed for field "Statistic.max_login_streak": %w`, err)}
		}
	}
	if v, ok := su.mutation.SearchScore(); ok {
		if err := statistic.SearchScoreValidator(v); err != nil {
			return &ValidationError{Name: "search_score", err: fmt.Errorf(`ent: validator failed for field "Statistic.search_score": %w`, err)}
		}
	}
	if su.mutation.UserCleared() && len(su.mutation.UserIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Statistic.user"`)
	}
	return nil
}

func (su *StatisticUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := su.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(statistic.Table, statistic.Columns, sqlgraph.NewFieldSpec(statistic.FieldID, field.TypeInt))
	if ps := su.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := su.mutation.GetType(); ok {
		_spec.SetField(statistic.FieldType, field.TypeEnum, value)
	}
	if value, ok := su.mutation.Period(); ok {
		_spec.SetField(statistic.FieldPeriod, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedPeriod(); ok {
		_spec.AddField(statistic.FieldPeriod, field.TypeInt, value)
	}
	if value, ok := su.mutation.Xp(); ok {
		_spec.SetField(statistic.FieldXp, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedXp(); ok {
		_spec.AddField(statistic.FieldXp, field.TypeInt, value)
	}
	if value, ok := su.mutation.MatchCount(); ok {
		_spec.SetField(statistic.FieldMatchCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedMatchCount(); ok {
		_spec.AddField(statistic.FieldMatchCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.WinsCount(); ok {
		_spec.SetField(statistic.FieldWinsCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedWinsCount(); ok {
		_spec.AddField(statistic.FieldWinsCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.LosesCount(); ok {
		_spec.SetField(statistic.FieldLosesCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedLosesCount(); ok {
		_spec.AddField(statistic.FieldLosesCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.DrawsCount(); ok {
		_spec.SetField(statistic.FieldDrawsCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedDrawsCount(); ok {
		_spec.AddField(statistic.FieldDrawsCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.ResultTime(); ok {
		_spec.SetField(statistic.FieldResultTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedResultTime(); ok {
		_spec.AddField(statistic.FieldResultTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.RetryTime(); ok {
		_spec.SetField(statistic.FieldRetryTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedRetryTime(); ok {
		_spec.AddField(statistic.FieldRetryTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.RetryCount(); ok {
		_spec.SetField(statistic.FieldRetryCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedRetryCount(); ok {
		_spec.AddField(statistic.FieldRetryCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.BestResultTime(); ok {
		_spec.SetField(statistic.FieldBestResultTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedBestResultTime(); ok {
		_spec.AddField(statistic.FieldBestResultTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.BestRetryCount(); ok {
		_spec.SetField(statistic.FieldBestRetryCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedBestRetryCount(); ok {
		_spec.AddField(statistic.FieldBestRetryCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.BestMatchTime(); ok {
		_spec.SetField(statistic.FieldBestMatchTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedBestMatchTime(); ok {
		_spec.AddField(statistic.FieldBestMatchTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.WorstResultTime(); ok {
		_spec.SetField(statistic.FieldWorstResultTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedWorstResultTime(); ok {
		_spec.AddField(statistic.FieldWorstResultTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.WorstRetryCount(); ok {
		_spec.SetField(statistic.FieldWorstRetryCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedWorstRetryCount(); ok {
		_spec.AddField(statistic.FieldWorstRetryCount, field.TypeInt, value)
	}
	if value, ok := su.mutation.WorstMatchTime(); ok {
		_spec.SetField(statistic.FieldWorstMatchTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedWorstMatchTime(); ok {
		_spec.AddField(statistic.FieldWorstMatchTime, field.TypeInt, value)
	}
	if value, ok := su.mutation.MaxWinStreak(); ok {
		_spec.SetField(statistic.FieldMaxWinStreak, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedMaxWinStreak(); ok {
		_spec.AddField(statistic.FieldMaxWinStreak, field.TypeInt, value)
	}
	if value, ok := su.mutation.MaxLoseStreak(); ok {
		_spec.SetField(statistic.FieldMaxLoseStreak, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedMaxLoseStreak(); ok {
		_spec.AddField(statistic.FieldMaxLoseStreak, field.TypeInt, value)
	}
	if value, ok := su.mutation.MaxLoginStreak(); ok {
		_spec.SetField(statistic.FieldMaxLoginStreak, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedMaxLoginStreak(); ok {
		_spec.AddField(statistic.FieldMaxLoginStreak, field.TypeInt, value)
	}
	if value, ok := su.mutation.SearchScore(); ok {
		_spec.SetField(statistic.FieldSearchScore, field.TypeInt, value)
	}
	if value, ok := su.mutation.AddedSearchScore(); ok {
		_spec.AddField(statistic.FieldSearchScore, field.TypeInt, value)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, su.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{statistic.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	su.mutation.done = true
	return n, nil
}

// StatisticUpdateOne is the builder for updating a single Statistic entity.
type StatisticUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *StatisticMutation
}

// SetType sets the "type" field.
func (suo *StatisticUpdateOne) SetType(s statistic.Type) *StatisticUpdateOne {
	suo.mutation.SetType(s)
	return suo
}

// SetNillableType sets the "type" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableType(s *statistic.Type) *StatisticUpdateOne {
	if s != nil {
		suo.SetType(*s)
	}
	return suo
}

// SetPeriod sets the "period" field.
func (suo *StatisticUpdateOne) SetPeriod(i int) *StatisticUpdateOne {
	suo.mutation.ResetPeriod()
	suo.mutation.SetPeriod(i)
	return suo
}

// SetNillablePeriod sets the "period" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillablePeriod(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetPeriod(*i)
	}
	return suo
}

// AddPeriod adds i to the "period" field.
func (suo *StatisticUpdateOne) AddPeriod(i int) *StatisticUpdateOne {
	suo.mutation.AddPeriod(i)
	return suo
}

// SetXp sets the "xp" field.
func (suo *StatisticUpdateOne) SetXp(i int) *StatisticUpdateOne {
	suo.mutation.ResetXp()
	suo.mutation.SetXp(i)
	return suo
}

// SetNillableXp sets the "xp" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableXp(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetXp(*i)
	}
	return suo
}

// AddXp adds i to the "xp" field.
func (suo *StatisticUpdateOne) AddXp(i int) *StatisticUpdateOne {
	suo.mutation.AddXp(i)
	return suo
}

// SetMatchCount sets the "match_count" field.
func (suo *StatisticUpdateOne) SetMatchCount(i int) *StatisticUpdateOne {
	suo.mutation.ResetMatchCount()
	suo.mutation.SetMatchCount(i)
	return suo
}

// SetNillableMatchCount sets the "match_count" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableMatchCount(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetMatchCount(*i)
	}
	return suo
}

// AddMatchCount adds i to the "match_count" field.
func (suo *StatisticUpdateOne) AddMatchCount(i int) *StatisticUpdateOne {
	suo.mutation.AddMatchCount(i)
	return suo
}

// SetWinsCount sets the "wins_count" field.
func (suo *StatisticUpdateOne) SetWinsCount(i int) *StatisticUpdateOne {
	suo.mutation.ResetWinsCount()
	suo.mutation.SetWinsCount(i)
	return suo
}

// SetNillableWinsCount sets the "wins_count" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableWinsCount(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetWinsCount(*i)
	}
	return suo
}

// AddWinsCount adds i to the "wins_count" field.
func (suo *StatisticUpdateOne) AddWinsCount(i int) *StatisticUpdateOne {
	suo.mutation.AddWinsCount(i)
	return suo
}

// SetLosesCount sets the "loses_count" field.
func (suo *StatisticUpdateOne) SetLosesCount(i int) *StatisticUpdateOne {
	suo.mutation.ResetLosesCount()
	suo.mutation.SetLosesCount(i)
	return suo
}

// SetNillableLosesCount sets the "loses_count" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableLosesCount(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetLosesCount(*i)
	}
	return suo
}

// AddLosesCount adds i to the "loses_count" field.
func (suo *StatisticUpdateOne) AddLosesCount(i int) *StatisticUpdateOne {
	suo.mutation.AddLosesCount(i)
	return suo
}

// SetDrawsCount sets the "draws_count" field.
func (suo *StatisticUpdateOne) SetDrawsCount(i int) *StatisticUpdateOne {
	suo.mutation.ResetDrawsCount()
	suo.mutation.SetDrawsCount(i)
	return suo
}

// SetNillableDrawsCount sets the "draws_count" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableDrawsCount(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetDrawsCount(*i)
	}
	return suo
}

// AddDrawsCount adds i to the "draws_count" field.
func (suo *StatisticUpdateOne) AddDrawsCount(i int) *StatisticUpdateOne {
	suo.mutation.AddDrawsCount(i)
	return suo
}

// SetResultTime sets the "result_time" field.
func (suo *StatisticUpdateOne) SetResultTime(i int) *StatisticUpdateOne {
	suo.mutation.ResetResultTime()
	suo.mutation.SetResultTime(i)
	return suo
}

// SetNillableResultTime sets the "result_time" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableResultTime(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetResultTime(*i)
	}
	return suo
}

// AddResultTime adds i to the "result_time" field.
func (suo *StatisticUpdateOne) AddResultTime(i int) *StatisticUpdateOne {
	suo.mutation.AddResultTime(i)
	return suo
}

// SetRetryTime sets the "retry_time" field.
func (suo *StatisticUpdateOne) SetRetryTime(i int) *StatisticUpdateOne {
	suo.mutation.ResetRetryTime()
	suo.mutation.SetRetryTime(i)
	return suo
}

// SetNillableRetryTime sets the "retry_time" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableRetryTime(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetRetryTime(*i)
	}
	return suo
}

// AddRetryTime adds i to the "retry_time" field.
func (suo *StatisticUpdateOne) AddRetryTime(i int) *StatisticUpdateOne {
	suo.mutation.AddRetryTime(i)
	return suo
}

// SetRetryCount sets the "retry_count" field.
func (suo *StatisticUpdateOne) SetRetryCount(i int) *StatisticUpdateOne {
	suo.mutation.ResetRetryCount()
	suo.mutation.SetRetryCount(i)
	return suo
}

// SetNillableRetryCount sets the "retry_count" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableRetryCount(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetRetryCount(*i)
	}
	return suo
}

// AddRetryCount adds i to the "retry_count" field.
func (suo *StatisticUpdateOne) AddRetryCount(i int) *StatisticUpdateOne {
	suo.mutation.AddRetryCount(i)
	return suo
}

// SetBestResultTime sets the "best_result_time" field.
func (suo *StatisticUpdateOne) SetBestResultTime(i int) *StatisticUpdateOne {
	suo.mutation.ResetBestResultTime()
	suo.mutation.SetBestResultTime(i)
	return suo
}

// SetNillableBestResultTime sets the "best_result_time" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableBestResultTime(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetBestResultTime(*i)
	}
	return suo
}

// AddBestResultTime adds i to the "best_result_time" field.
func (suo *StatisticUpdateOne) AddBestResultTime(i int) *StatisticUpdateOne {
	suo.mutation.AddBestResultTime(i)
	return suo
}

// SetBestRetryCount sets the "best_retry_count" field.
func (suo *StatisticUpdateOne) SetBestRetryCount(i int) *StatisticUpdateOne {
	suo.mutation.ResetBestRetryCount()
	suo.mutation.SetBestRetryCount(i)
	return suo
}

// SetNillableBestRetryCount sets the "best_retry_count" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableBestRetryCount(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetBestRetryCount(*i)
	}
	return suo
}

// AddBestRetryCount adds i to the "best_retry_count" field.
func (suo *StatisticUpdateOne) AddBestRetryCount(i int) *StatisticUpdateOne {
	suo.mutation.AddBestRetryCount(i)
	return suo
}

// SetBestMatchTime sets the "best_match_time" field.
func (suo *StatisticUpdateOne) SetBestMatchTime(i int) *StatisticUpdateOne {
	suo.mutation.ResetBestMatchTime()
	suo.mutation.SetBestMatchTime(i)
	return suo
}

// SetNillableBestMatchTime sets the "best_match_time" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableBestMatchTime(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetBestMatchTime(*i)
	}
	return suo
}

// AddBestMatchTime adds i to the "best_match_time" field.
func (suo *StatisticUpdateOne) AddBestMatchTime(i int) *StatisticUpdateOne {
	suo.mutation.AddBestMatchTime(i)
	return suo
}

// SetWorstResultTime sets the "worst_result_time" field.
func (suo *StatisticUpdateOne) SetWorstResultTime(i int) *StatisticUpdateOne {
	suo.mutation.ResetWorstResultTime()
	suo.mutation.SetWorstResultTime(i)
	return suo
}

// SetNillableWorstResultTime sets the "worst_result_time" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableWorstResultTime(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetWorstResultTime(*i)
	}
	return suo
}

// AddWorstResultTime adds i to the "worst_result_time" field.
func (suo *StatisticUpdateOne) AddWorstResultTime(i int) *StatisticUpdateOne {
	suo.mutation.AddWorstResultTime(i)
	return suo
}

// SetWorstRetryCount sets the "worst_retry_count" field.
func (suo *StatisticUpdateOne) SetWorstRetryCount(i int) *StatisticUpdateOne {
	suo.mutation.ResetWorstRetryCount()
	suo.mutation.SetWorstRetryCount(i)
	return suo
}

// SetNillableWorstRetryCount sets the "worst_retry_count" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableWorstRetryCount(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetWorstRetryCount(*i)
	}
	return suo
}

// AddWorstRetryCount adds i to the "worst_retry_count" field.
func (suo *StatisticUpdateOne) AddWorstRetryCount(i int) *StatisticUpdateOne {
	suo.mutation.AddWorstRetryCount(i)
	return suo
}

// SetWorstMatchTime sets the "worst_match_time" field.
func (suo *StatisticUpdateOne) SetWorstMatchTime(i int) *StatisticUpdateOne {
	suo.mutation.ResetWorstMatchTime()
	suo.mutation.SetWorstMatchTime(i)
	return suo
}

// SetNillableWorstMatchTime sets the "worst_match_time" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableWorstMatchTime(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetWorstMatchTime(*i)
	}
	return suo
}

// AddWorstMatchTime adds i to the "worst_match_time" field.
func (suo *StatisticUpdateOne) AddWorstMatchTime(i int) *StatisticUpdateOne {
	suo.mutation.AddWorstMatchTime(i)
	return suo
}

// SetMaxWinStreak sets the "max_win_streak" field.
func (suo *StatisticUpdateOne) SetMaxWinStreak(i int) *StatisticUpdateOne {
	suo.mutation.ResetMaxWinStreak()
	suo.mutation.SetMaxWinStreak(i)
	return suo
}

// SetNillableMaxWinStreak sets the "max_win_streak" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableMaxWinStreak(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetMaxWinStreak(*i)
	}
	return suo
}

// AddMaxWinStreak adds i to the "max_win_streak" field.
func (suo *StatisticUpdateOne) AddMaxWinStreak(i int) *StatisticUpdateOne {
	suo.mutation.AddMaxWinStreak(i)
	return suo
}

// SetMaxLoseStreak sets the "max_lose_streak" field.
func (suo *StatisticUpdateOne) SetMaxLoseStreak(i int) *StatisticUpdateOne {
	suo.mutation.ResetMaxLoseStreak()
	suo.mutation.SetMaxLoseStreak(i)
	return suo
}

// SetNillableMaxLoseStreak sets the "max_lose_streak" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableMaxLoseStreak(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetMaxLoseStreak(*i)
	}
	return suo
}

// AddMaxLoseStreak adds i to the "max_lose_streak" field.
func (suo *StatisticUpdateOne) AddMaxLoseStreak(i int) *StatisticUpdateOne {
	suo.mutation.AddMaxLoseStreak(i)
	return suo
}

// SetMaxLoginStreak sets the "max_login_streak" field.
func (suo *StatisticUpdateOne) SetMaxLoginStreak(i int) *StatisticUpdateOne {
	suo.mutation.ResetMaxLoginStreak()
	suo.mutation.SetMaxLoginStreak(i)
	return suo
}

// SetNillableMaxLoginStreak sets the "max_login_streak" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableMaxLoginStreak(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetMaxLoginStreak(*i)
	}
	return suo
}

// AddMaxLoginStreak adds i to the "max_login_streak" field.
func (suo *StatisticUpdateOne) AddMaxLoginStreak(i int) *StatisticUpdateOne {
	suo.mutation.AddMaxLoginStreak(i)
	return suo
}

// SetSearchScore sets the "search_score" field.
func (suo *StatisticUpdateOne) SetSearchScore(i int) *StatisticUpdateOne {
	suo.mutation.ResetSearchScore()
	suo.mutation.SetSearchScore(i)
	return suo
}

// SetNillableSearchScore sets the "search_score" field if the given value is not nil.
func (suo *StatisticUpdateOne) SetNillableSearchScore(i *int) *StatisticUpdateOne {
	if i != nil {
		suo.SetSearchScore(*i)
	}
	return suo
}

// AddSearchScore adds i to the "search_score" field.
func (suo *StatisticUpdateOne) AddSearchScore(i int) *StatisticUpdateOne {
	suo.mutation.AddSearchScore(i)
	return suo
}

// Mutation returns the StatisticMutation object of the builder.
func (suo *StatisticUpdateOne) Mutation() *StatisticMutation {
	return suo.mutation
}

// Where appends a list predicates to the StatisticUpdate builder.
func (suo *StatisticUpdateOne) Where(ps ...predicate.Statistic) *StatisticUpdateOne {
	suo.mutation.Where(ps...)
	return suo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (suo *StatisticUpdateOne) Select(field string, fields ...string) *StatisticUpdateOne {
	suo.fields = append([]string{field}, fields...)
	return suo
}

// Save executes the query and returns the updated Statistic entity.
func (suo *StatisticUpdateOne) Save(ctx context.Context) (*Statistic, error) {
	return withHooks(ctx, suo.sqlSave, suo.mutation, suo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (suo *StatisticUpdateOne) SaveX(ctx context.Context) *Statistic {
	node, err := suo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (suo *StatisticUpdateOne) Exec(ctx context.Context) error {
	_, err := suo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (suo *StatisticUpdateOne) ExecX(ctx context.Context) {
	if err := suo.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (suo *StatisticUpdateOne) check() error {
	if v, ok := suo.mutation.GetType(); ok {
		if err := statistic.TypeValidator(v); err != nil {
			return &ValidationError{Name: "type", err: fmt.Errorf(`ent: validator failed for field "Statistic.type": %w`, err)}
		}
	}
	if v, ok := suo.mutation.Period(); ok {
		if err := statistic.PeriodValidator(v); err != nil {
			return &ValidationError{Name: "period", err: fmt.Errorf(`ent: validator failed for field "Statistic.period": %w`, err)}
		}
	}
	if v, ok := suo.mutation.Xp(); ok {
		if err := statistic.XpValidator(v); err != nil {
			return &ValidationError{Name: "xp", err: fmt.Errorf(`ent: validator failed for field "Statistic.xp": %w`, err)}
		}
	}
	if v, ok := suo.mutation.MatchCount(); ok {
		if err := statistic.MatchCountValidator(v); err != nil {
			return &ValidationError{Name: "match_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.match_count": %w`, err)}
		}
	}
	if v, ok := suo.mutation.WinsCount(); ok {
		if err := statistic.WinsCountValidator(v); err != nil {
			return &ValidationError{Name: "wins_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.wins_count": %w`, err)}
		}
	}
	if v, ok := suo.mutation.LosesCount(); ok {
		if err := statistic.LosesCountValidator(v); err != nil {
			return &ValidationError{Name: "loses_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.loses_count": %w`, err)}
		}
	}
	if v, ok := suo.mutation.DrawsCount(); ok {
		if err := statistic.DrawsCountValidator(v); err != nil {
			return &ValidationError{Name: "draws_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.draws_count": %w`, err)}
		}
	}
	if v, ok := suo.mutation.ResultTime(); ok {
		if err := statistic.ResultTimeValidator(v); err != nil {
			return &ValidationError{Name: "result_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.result_time": %w`, err)}
		}
	}
	if v, ok := suo.mutation.RetryTime(); ok {
		if err := statistic.RetryTimeValidator(v); err != nil {
			return &ValidationError{Name: "retry_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.retry_time": %w`, err)}
		}
	}
	if v, ok := suo.mutation.RetryCount(); ok {
		if err := statistic.RetryCountValidator(v); err != nil {
			return &ValidationError{Name: "retry_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.retry_count": %w`, err)}
		}
	}
	if v, ok := suo.mutation.BestResultTime(); ok {
		if err := statistic.BestResultTimeValidator(v); err != nil {
			return &ValidationError{Name: "best_result_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.best_result_time": %w`, err)}
		}
	}
	if v, ok := suo.mutation.BestRetryCount(); ok {
		if err := statistic.BestRetryCountValidator(v); err != nil {
			return &ValidationError{Name: "best_retry_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.best_retry_count": %w`, err)}
		}
	}
	if v, ok := suo.mutation.BestMatchTime(); ok {
		if err := statistic.BestMatchTimeValidator(v); err != nil {
			return &ValidationError{Name: "best_match_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.best_match_time": %w`, err)}
		}
	}
	if v, ok := suo.mutation.WorstResultTime(); ok {
		if err := statistic.WorstResultTimeValidator(v); err != nil {
			return &ValidationError{Name: "worst_result_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.worst_result_time": %w`, err)}
		}
	}
	if v, ok := suo.mutation.WorstRetryCount(); ok {
		if err := statistic.WorstRetryCountValidator(v); err != nil {
			return &ValidationError{Name: "worst_retry_count", err: fmt.Errorf(`ent: validator failed for field "Statistic.worst_retry_count": %w`, err)}
		}
	}
	if v, ok := suo.mutation.WorstMatchTime(); ok {
		if err := statistic.WorstMatchTimeValidator(v); err != nil {
			return &ValidationError{Name: "worst_match_time", err: fmt.Errorf(`ent: validator failed for field "Statistic.worst_match_time": %w`, err)}
		}
	}
	if v, ok := suo.mutation.MaxWinStreak(); ok {
		if err := statistic.MaxWinStreakValidator(v); err != nil {
			return &ValidationError{Name: "max_win_streak", err: fmt.Errorf(`ent: validator failed for field "Statistic.max_win_streak": %w`, err)}
		}
	}
	if v, ok := suo.mutation.MaxLoseStreak(); ok {
		if err := statistic.MaxLoseStreakValidator(v); err != nil {
			return &ValidationError{Name: "max_lose_streak", err: fmt.Errorf(`ent: validator failed for field "Statistic.max_lose_streak": %w`, err)}
		}
	}
	if v, ok := suo.mutation.MaxLoginStreak(); ok {
		if err := statistic.MaxLoginStreakValidator(v); err != nil {
			return &ValidationError{Name: "max_login_streak", err: fmt.Errorf(`ent: validator failed for field "Statistic.max_login_streak": %w`, err)}
		}
	}
	if v, ok := suo.mutation.SearchScore(); ok {
		if err := statistic.SearchScoreValidator(v); err != nil {
			return &ValidationError{Name: "search_score", err: fmt.Errorf(`ent: validator failed for field "Statistic.search_score": %w`, err)}
		}
	}
	if suo.mutation.UserCleared() && len(suo.mutation.UserIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Statistic.user"`)
	}
	return nil
}

func (suo *StatisticUpdateOne) sqlSave(ctx context.Context) (_node *Statistic, err error) {
	if err := suo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(statistic.Table, statistic.Columns, sqlgraph.NewFieldSpec(statistic.FieldID, field.TypeInt))
	id, ok := suo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Statistic.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := suo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, statistic.FieldID)
		for _, f := range fields {
			if !statistic.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != statistic.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := suo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := suo.mutation.GetType(); ok {
		_spec.SetField(statistic.FieldType, field.TypeEnum, value)
	}
	if value, ok := suo.mutation.Period(); ok {
		_spec.SetField(statistic.FieldPeriod, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedPeriod(); ok {
		_spec.AddField(statistic.FieldPeriod, field.TypeInt, value)
	}
	if value, ok := suo.mutation.Xp(); ok {
		_spec.SetField(statistic.FieldXp, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedXp(); ok {
		_spec.AddField(statistic.FieldXp, field.TypeInt, value)
	}
	if value, ok := suo.mutation.MatchCount(); ok {
		_spec.SetField(statistic.FieldMatchCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedMatchCount(); ok {
		_spec.AddField(statistic.FieldMatchCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.WinsCount(); ok {
		_spec.SetField(statistic.FieldWinsCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedWinsCount(); ok {
		_spec.AddField(statistic.FieldWinsCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.LosesCount(); ok {
		_spec.SetField(statistic.FieldLosesCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedLosesCount(); ok {
		_spec.AddField(statistic.FieldLosesCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.DrawsCount(); ok {
		_spec.SetField(statistic.FieldDrawsCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedDrawsCount(); ok {
		_spec.AddField(statistic.FieldDrawsCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.ResultTime(); ok {
		_spec.SetField(statistic.FieldResultTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedResultTime(); ok {
		_spec.AddField(statistic.FieldResultTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.RetryTime(); ok {
		_spec.SetField(statistic.FieldRetryTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedRetryTime(); ok {
		_spec.AddField(statistic.FieldRetryTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.RetryCount(); ok {
		_spec.SetField(statistic.FieldRetryCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedRetryCount(); ok {
		_spec.AddField(statistic.FieldRetryCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.BestResultTime(); ok {
		_spec.SetField(statistic.FieldBestResultTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedBestResultTime(); ok {
		_spec.AddField(statistic.FieldBestResultTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.BestRetryCount(); ok {
		_spec.SetField(statistic.FieldBestRetryCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedBestRetryCount(); ok {
		_spec.AddField(statistic.FieldBestRetryCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.BestMatchTime(); ok {
		_spec.SetField(statistic.FieldBestMatchTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedBestMatchTime(); ok {
		_spec.AddField(statistic.FieldBestMatchTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.WorstResultTime(); ok {
		_spec.SetField(statistic.FieldWorstResultTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedWorstResultTime(); ok {
		_spec.AddField(statistic.FieldWorstResultTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.WorstRetryCount(); ok {
		_spec.SetField(statistic.FieldWorstRetryCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedWorstRetryCount(); ok {
		_spec.AddField(statistic.FieldWorstRetryCount, field.TypeInt, value)
	}
	if value, ok := suo.mutation.WorstMatchTime(); ok {
		_spec.SetField(statistic.FieldWorstMatchTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedWorstMatchTime(); ok {
		_spec.AddField(statistic.FieldWorstMatchTime, field.TypeInt, value)
	}
	if value, ok := suo.mutation.MaxWinStreak(); ok {
		_spec.SetField(statistic.FieldMaxWinStreak, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedMaxWinStreak(); ok {
		_spec.AddField(statistic.FieldMaxWinStreak, field.TypeInt, value)
	}
	if value, ok := suo.mutation.MaxLoseStreak(); ok {
		_spec.SetField(statistic.FieldMaxLoseStreak, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedMaxLoseStreak(); ok {
		_spec.AddField(statistic.FieldMaxLoseStreak, field.TypeInt, value)
	}
	if value, ok := suo.mutation.MaxLoginStreak(); ok {
		_spec.SetField(statistic.FieldMaxLoginStreak, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedMaxLoginStreak(); ok {
		_spec.AddField(statistic.FieldMaxLoginStreak, field.TypeInt, value)
	}
	if value, ok := suo.mutation.SearchScore(); ok {
		_spec.SetField(statistic.FieldSearchScore, field.TypeInt, value)
	}
	if value, ok := suo.mutation.AddedSearchScore(); ok {
		_spec.AddField(statistic.FieldSearchScore, field.TypeInt, value)
	}
	_node = &Statistic{config: suo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, suo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{statistic.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	suo.mutation.done = true
	return _node, nil
}
