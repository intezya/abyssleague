// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/friendrequest"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/gameitem"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/inventoryitem"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/match"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/playermatchresult"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/predicate"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/schema/access_level"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/statistic"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/user"
	"github.com/intezya/abyssleague/services/abysscore/internal/infrastructure/ent/userbalance"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeFriendRequest     = "FriendRequest"
	TypeGameItem          = "GameItem"
	TypeInventoryItem     = "InventoryItem"
	TypeMatch             = "Match"
	TypePlayerMatchResult = "PlayerMatchResult"
	TypeStatistic         = "Statistic"
	TypeUser              = "User"
	TypeUserBalance       = "UserBalance"
)

// FriendRequestMutation represents an operation that mutates the FriendRequest nodes in the graph.
type FriendRequestMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	clearedFields    map[string]struct{}
	from_user        *int
	clearedfrom_user bool
	to_user          *int
	clearedto_user   bool
	done             bool
	oldValue         func(context.Context) (*FriendRequest, error)
	predicates       []predicate.FriendRequest
}

var _ ent.Mutation = (*FriendRequestMutation)(nil)

// friendrequestOption allows management of the mutation configuration using functional options.
type friendrequestOption func(*FriendRequestMutation)

// newFriendRequestMutation creates new mutation for the FriendRequest entity.
func newFriendRequestMutation(c config, op Op, opts ...friendrequestOption) *FriendRequestMutation {
	m := &FriendRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendRequestID sets the ID field of the mutation.
func withFriendRequestID(id int) friendrequestOption {
	return func(m *FriendRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *FriendRequest
		)
		m.oldValue = func(ctx context.Context) (*FriendRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FriendRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendRequest sets the old FriendRequest of the mutation.
func withFriendRequest(node *FriendRequest) friendrequestOption {
	return func(m *FriendRequestMutation) {
		m.oldValue = func(context.Context) (*FriendRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FriendRequest entities.
func (m *FriendRequestMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendRequestMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendRequestMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FriendRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFromUserID sets the "from_user_id" field.
func (m *FriendRequestMutation) SetFromUserID(i int) {
	m.from_user = &i
}

// FromUserID returns the value of the "from_user_id" field in the mutation.
func (m *FriendRequestMutation) FromUserID() (r int, exists bool) {
	v := m.from_user
	if v == nil {
		return
	}
	return *v, true
}

// OldFromUserID returns the old "from_user_id" field's value of the FriendRequest entity.
// If the FriendRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendRequestMutation) OldFromUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromUserID: %w", err)
	}
	return oldValue.FromUserID, nil
}

// ResetFromUserID resets all changes to the "from_user_id" field.
func (m *FriendRequestMutation) ResetFromUserID() {
	m.from_user = nil
}

// SetToUserID sets the "to_user_id" field.
func (m *FriendRequestMutation) SetToUserID(i int) {
	m.to_user = &i
}

// ToUserID returns the value of the "to_user_id" field in the mutation.
func (m *FriendRequestMutation) ToUserID() (r int, exists bool) {
	v := m.to_user
	if v == nil {
		return
	}
	return *v, true
}

// OldToUserID returns the old "to_user_id" field's value of the FriendRequest entity.
// If the FriendRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendRequestMutation) OldToUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToUserID: %w", err)
	}
	return oldValue.ToUserID, nil
}

// ResetToUserID resets all changes to the "to_user_id" field.
func (m *FriendRequestMutation) ResetToUserID() {
	m.to_user = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FriendRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FriendRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FriendRequest entity.
// If the FriendRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FriendRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFromUser clears the "from_user" edge to the User entity.
func (m *FriendRequestMutation) ClearFromUser() {
	m.clearedfrom_user = true
	m.clearedFields[friendrequest.FieldFromUserID] = struct{}{}
}

// FromUserCleared reports if the "from_user" edge to the User entity was cleared.
func (m *FriendRequestMutation) FromUserCleared() bool {
	return m.clearedfrom_user
}

// FromUserIDs returns the "from_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromUserID instead. It exists only for internal usage by the builders.
func (m *FriendRequestMutation) FromUserIDs() (ids []int) {
	if id := m.from_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromUser resets all changes to the "from_user" edge.
func (m *FriendRequestMutation) ResetFromUser() {
	m.from_user = nil
	m.clearedfrom_user = false
}

// ClearToUser clears the "to_user" edge to the User entity.
func (m *FriendRequestMutation) ClearToUser() {
	m.clearedto_user = true
	m.clearedFields[friendrequest.FieldToUserID] = struct{}{}
}

// ToUserCleared reports if the "to_user" edge to the User entity was cleared.
func (m *FriendRequestMutation) ToUserCleared() bool {
	return m.clearedto_user
}

// ToUserIDs returns the "to_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToUserID instead. It exists only for internal usage by the builders.
func (m *FriendRequestMutation) ToUserIDs() (ids []int) {
	if id := m.to_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToUser resets all changes to the "to_user" edge.
func (m *FriendRequestMutation) ResetToUser() {
	m.to_user = nil
	m.clearedto_user = false
}

// Where appends a list predicates to the FriendRequestMutation builder.
func (m *FriendRequestMutation) Where(ps ...predicate.FriendRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FriendRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FriendRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FriendRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FriendRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FriendRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FriendRequest).
func (m *FriendRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendRequestMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.from_user != nil {
		fields = append(fields, friendrequest.FieldFromUserID)
	}
	if m.to_user != nil {
		fields = append(fields, friendrequest.FieldToUserID)
	}
	if m.created_at != nil {
		fields = append(fields, friendrequest.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendrequest.FieldFromUserID:
		return m.FromUserID()
	case friendrequest.FieldToUserID:
		return m.ToUserID()
	case friendrequest.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendrequest.FieldFromUserID:
		return m.OldFromUserID(ctx)
	case friendrequest.FieldToUserID:
		return m.OldToUserID(ctx)
	case friendrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FriendRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendrequest.FieldFromUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromUserID(v)
		return nil
	case friendrequest.FieldToUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToUserID(v)
		return nil
	case friendrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FriendRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendRequestMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FriendRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FriendRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendRequestMutation) ResetField(name string) error {
	switch name {
	case friendrequest.FieldFromUserID:
		m.ResetFromUserID()
		return nil
	case friendrequest.FieldToUserID:
		m.ResetToUserID()
		return nil
	case friendrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FriendRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_user != nil {
		edges = append(edges, friendrequest.EdgeFromUser)
	}
	if m.to_user != nil {
		edges = append(edges, friendrequest.EdgeToUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendrequest.EdgeFromUser:
		if id := m.from_user; id != nil {
			return []ent.Value{*id}
		}
	case friendrequest.EdgeToUser:
		if id := m.to_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_user {
		edges = append(edges, friendrequest.EdgeFromUser)
	}
	if m.clearedto_user {
		edges = append(edges, friendrequest.EdgeToUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case friendrequest.EdgeFromUser:
		return m.clearedfrom_user
	case friendrequest.EdgeToUser:
		return m.clearedto_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendRequestMutation) ClearEdge(name string) error {
	switch name {
	case friendrequest.EdgeFromUser:
		m.ClearFromUser()
		return nil
	case friendrequest.EdgeToUser:
		m.ClearToUser()
		return nil
	}
	return fmt.Errorf("unknown FriendRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendRequestMutation) ResetEdge(name string) error {
	switch name {
	case friendrequest.EdgeFromUser:
		m.ResetFromUser()
		return nil
	case friendrequest.EdgeToUser:
		m.ResetToUser()
		return nil
	}
	return fmt.Errorf("unknown FriendRequest edge %s", name)
}

// GameItemMutation represents an operation that mutates the GameItem nodes in the graph.
type GameItemMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	name                   *string
	collection             *string
	_type                  *int
	add_type               *int
	rarity                 *int
	addrarity              *int
	created_at             *time.Time
	clearedFields          map[string]struct{}
	inventory_items        map[int]struct{}
	removedinventory_items map[int]struct{}
	clearedinventory_items bool
	done                   bool
	oldValue               func(context.Context) (*GameItem, error)
	predicates             []predicate.GameItem
}

var _ ent.Mutation = (*GameItemMutation)(nil)

// gameitemOption allows management of the mutation configuration using functional options.
type gameitemOption func(*GameItemMutation)

// newGameItemMutation creates new mutation for the GameItem entity.
func newGameItemMutation(c config, op Op, opts ...gameitemOption) *GameItemMutation {
	m := &GameItemMutation{
		config:        c,
		op:            op,
		typ:           TypeGameItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameItemID sets the ID field of the mutation.
func withGameItemID(id int) gameitemOption {
	return func(m *GameItemMutation) {
		var (
			err   error
			once  sync.Once
			value *GameItem
		)
		m.oldValue = func(ctx context.Context) (*GameItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameItem sets the old GameItem of the mutation.
func withGameItem(node *GameItem) gameitemOption {
	return func(m *GameItemMutation) {
		m.oldValue = func(context.Context) (*GameItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameItem entities.
func (m *GameItemMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *GameItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GameItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GameItem entity.
// If the GameItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GameItemMutation) ResetName() {
	m.name = nil
}

// SetCollection sets the "collection" field.
func (m *GameItemMutation) SetCollection(s string) {
	m.collection = &s
}

// Collection returns the value of the "collection" field in the mutation.
func (m *GameItemMutation) Collection() (r string, exists bool) {
	v := m.collection
	if v == nil {
		return
	}
	return *v, true
}

// OldCollection returns the old "collection" field's value of the GameItem entity.
// If the GameItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameItemMutation) OldCollection(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollection: %w", err)
	}
	return oldValue.Collection, nil
}

// ResetCollection resets all changes to the "collection" field.
func (m *GameItemMutation) ResetCollection() {
	m.collection = nil
}

// SetType sets the "type" field.
func (m *GameItemMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *GameItemMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the GameItem entity.
// If the GameItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameItemMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *GameItemMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *GameItemMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *GameItemMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetRarity sets the "rarity" field.
func (m *GameItemMutation) SetRarity(i int) {
	m.rarity = &i
	m.addrarity = nil
}

// Rarity returns the value of the "rarity" field in the mutation.
func (m *GameItemMutation) Rarity() (r int, exists bool) {
	v := m.rarity
	if v == nil {
		return
	}
	return *v, true
}

// OldRarity returns the old "rarity" field's value of the GameItem entity.
// If the GameItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameItemMutation) OldRarity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRarity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRarity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRarity: %w", err)
	}
	return oldValue.Rarity, nil
}

// AddRarity adds i to the "rarity" field.
func (m *GameItemMutation) AddRarity(i int) {
	if m.addrarity != nil {
		*m.addrarity += i
	} else {
		m.addrarity = &i
	}
}

// AddedRarity returns the value that was added to the "rarity" field in this mutation.
func (m *GameItemMutation) AddedRarity() (r int, exists bool) {
	v := m.addrarity
	if v == nil {
		return
	}
	return *v, true
}

// ResetRarity resets all changes to the "rarity" field.
func (m *GameItemMutation) ResetRarity() {
	m.rarity = nil
	m.addrarity = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GameItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GameItem entity.
// If the GameItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddInventoryItemIDs adds the "inventory_items" edge to the InventoryItem entity by ids.
func (m *GameItemMutation) AddInventoryItemIDs(ids ...int) {
	if m.inventory_items == nil {
		m.inventory_items = make(map[int]struct{})
	}
	for i := range ids {
		m.inventory_items[ids[i]] = struct{}{}
	}
}

// ClearInventoryItems clears the "inventory_items" edge to the InventoryItem entity.
func (m *GameItemMutation) ClearInventoryItems() {
	m.clearedinventory_items = true
}

// InventoryItemsCleared reports if the "inventory_items" edge to the InventoryItem entity was cleared.
func (m *GameItemMutation) InventoryItemsCleared() bool {
	return m.clearedinventory_items
}

// RemoveInventoryItemIDs removes the "inventory_items" edge to the InventoryItem entity by IDs.
func (m *GameItemMutation) RemoveInventoryItemIDs(ids ...int) {
	if m.removedinventory_items == nil {
		m.removedinventory_items = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.inventory_items, ids[i])
		m.removedinventory_items[ids[i]] = struct{}{}
	}
}

// RemovedInventoryItems returns the removed IDs of the "inventory_items" edge to the InventoryItem entity.
func (m *GameItemMutation) RemovedInventoryItemsIDs() (ids []int) {
	for id := range m.removedinventory_items {
		ids = append(ids, id)
	}
	return
}

// InventoryItemsIDs returns the "inventory_items" edge IDs in the mutation.
func (m *GameItemMutation) InventoryItemsIDs() (ids []int) {
	for id := range m.inventory_items {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryItems resets all changes to the "inventory_items" edge.
func (m *GameItemMutation) ResetInventoryItems() {
	m.inventory_items = nil
	m.clearedinventory_items = false
	m.removedinventory_items = nil
}

// Where appends a list predicates to the GameItemMutation builder.
func (m *GameItemMutation) Where(ps ...predicate.GameItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameItem).
func (m *GameItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameItemMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, gameitem.FieldName)
	}
	if m.collection != nil {
		fields = append(fields, gameitem.FieldCollection)
	}
	if m._type != nil {
		fields = append(fields, gameitem.FieldType)
	}
	if m.rarity != nil {
		fields = append(fields, gameitem.FieldRarity)
	}
	if m.created_at != nil {
		fields = append(fields, gameitem.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gameitem.FieldName:
		return m.Name()
	case gameitem.FieldCollection:
		return m.Collection()
	case gameitem.FieldType:
		return m.GetType()
	case gameitem.FieldRarity:
		return m.Rarity()
	case gameitem.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gameitem.FieldName:
		return m.OldName(ctx)
	case gameitem.FieldCollection:
		return m.OldCollection(ctx)
	case gameitem.FieldType:
		return m.OldType(ctx)
	case gameitem.FieldRarity:
		return m.OldRarity(ctx)
	case gameitem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown GameItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gameitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case gameitem.FieldCollection:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollection(v)
		return nil
	case gameitem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case gameitem.FieldRarity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRarity(v)
		return nil
	case gameitem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown GameItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameItemMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, gameitem.FieldType)
	}
	if m.addrarity != nil {
		fields = append(fields, gameitem.FieldRarity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gameitem.FieldType:
		return m.AddedType()
	case gameitem.FieldRarity:
		return m.AddedRarity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gameitem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case gameitem.FieldRarity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRarity(v)
		return nil
	}
	return fmt.Errorf("unknown GameItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameItemMutation) ResetField(name string) error {
	switch name {
	case gameitem.FieldName:
		m.ResetName()
		return nil
	case gameitem.FieldCollection:
		m.ResetCollection()
		return nil
	case gameitem.FieldType:
		m.ResetType()
		return nil
	case gameitem.FieldRarity:
		m.ResetRarity()
		return nil
	case gameitem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown GameItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.inventory_items != nil {
		edges = append(edges, gameitem.EdgeInventoryItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gameitem.EdgeInventoryItems:
		ids := make([]ent.Value, 0, len(m.inventory_items))
		for id := range m.inventory_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinventory_items != nil {
		edges = append(edges, gameitem.EdgeInventoryItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gameitem.EdgeInventoryItems:
		ids := make([]ent.Value, 0, len(m.removedinventory_items))
		for id := range m.removedinventory_items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinventory_items {
		edges = append(edges, gameitem.EdgeInventoryItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameItemMutation) EdgeCleared(name string) bool {
	switch name {
	case gameitem.EdgeInventoryItems:
		return m.clearedinventory_items
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameItemMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown GameItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameItemMutation) ResetEdge(name string) error {
	switch name {
	case gameitem.EdgeInventoryItems:
		m.ResetInventoryItems()
		return nil
	}
	return fmt.Errorf("unknown GameItem edge %s", name)
}

// InventoryItemMutation represents an operation that mutates the InventoryItem nodes in the graph.
type InventoryItemMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	received_from_id    *int
	addreceived_from_id *int
	obtained_at         *time.Time
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	item                *int
	cleareditem         bool
	done                bool
	oldValue            func(context.Context) (*InventoryItem, error)
	predicates          []predicate.InventoryItem
}

var _ ent.Mutation = (*InventoryItemMutation)(nil)

// inventoryitemOption allows management of the mutation configuration using functional options.
type inventoryitemOption func(*InventoryItemMutation)

// newInventoryItemMutation creates new mutation for the InventoryItem entity.
func newInventoryItemMutation(c config, op Op, opts ...inventoryitemOption) *InventoryItemMutation {
	m := &InventoryItemMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryItemID sets the ID field of the mutation.
func withInventoryItemID(id int) inventoryitemOption {
	return func(m *InventoryItemMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryItem
		)
		m.oldValue = func(ctx context.Context) (*InventoryItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryItem sets the old InventoryItem of the mutation.
func withInventoryItem(node *InventoryItem) inventoryitemOption {
	return func(m *InventoryItemMutation) {
		m.oldValue = func(context.Context) (*InventoryItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InventoryItem entities.
func (m *InventoryItemMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryItemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryItemMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *InventoryItemMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InventoryItemMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InventoryItemMutation) ResetUserID() {
	m.user = nil
}

// SetItemID sets the "item_id" field.
func (m *InventoryItemMutation) SetItemID(i int) {
	m.item = &i
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *InventoryItemMutation) ItemID() (r int, exists bool) {
	v := m.item
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldItemID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// ResetItemID resets all changes to the "item_id" field.
func (m *InventoryItemMutation) ResetItemID() {
	m.item = nil
}

// SetReceivedFromID sets the "received_from_id" field.
func (m *InventoryItemMutation) SetReceivedFromID(i int) {
	m.received_from_id = &i
	m.addreceived_from_id = nil
}

// ReceivedFromID returns the value of the "received_from_id" field in the mutation.
func (m *InventoryItemMutation) ReceivedFromID() (r int, exists bool) {
	v := m.received_from_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReceivedFromID returns the old "received_from_id" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldReceivedFromID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceivedFromID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceivedFromID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceivedFromID: %w", err)
	}
	return oldValue.ReceivedFromID, nil
}

// AddReceivedFromID adds i to the "received_from_id" field.
func (m *InventoryItemMutation) AddReceivedFromID(i int) {
	if m.addreceived_from_id != nil {
		*m.addreceived_from_id += i
	} else {
		m.addreceived_from_id = &i
	}
}

// AddedReceivedFromID returns the value that was added to the "received_from_id" field in this mutation.
func (m *InventoryItemMutation) AddedReceivedFromID() (r int, exists bool) {
	v := m.addreceived_from_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReceivedFromID resets all changes to the "received_from_id" field.
func (m *InventoryItemMutation) ResetReceivedFromID() {
	m.received_from_id = nil
	m.addreceived_from_id = nil
}

// SetObtainedAt sets the "obtained_at" field.
func (m *InventoryItemMutation) SetObtainedAt(t time.Time) {
	m.obtained_at = &t
}

// ObtainedAt returns the value of the "obtained_at" field in the mutation.
func (m *InventoryItemMutation) ObtainedAt() (r time.Time, exists bool) {
	v := m.obtained_at
	if v == nil {
		return
	}
	return *v, true
}

// OldObtainedAt returns the old "obtained_at" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldObtainedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObtainedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObtainedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObtainedAt: %w", err)
	}
	return oldValue.ObtainedAt, nil
}

// ResetObtainedAt resets all changes to the "obtained_at" field.
func (m *InventoryItemMutation) ResetObtainedAt() {
	m.obtained_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *InventoryItemMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[inventoryitem.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *InventoryItemMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *InventoryItemMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *InventoryItemMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearItem clears the "item" edge to the GameItem entity.
func (m *InventoryItemMutation) ClearItem() {
	m.cleareditem = true
	m.clearedFields[inventoryitem.FieldItemID] = struct{}{}
}

// ItemCleared reports if the "item" edge to the GameItem entity was cleared.
func (m *InventoryItemMutation) ItemCleared() bool {
	return m.cleareditem
}

// ItemIDs returns the "item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ItemID instead. It exists only for internal usage by the builders.
func (m *InventoryItemMutation) ItemIDs() (ids []int) {
	if id := m.item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *InventoryItemMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
}

// Where appends a list predicates to the InventoryItemMutation builder.
func (m *InventoryItemMutation) Where(ps ...predicate.InventoryItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryItem).
func (m *InventoryItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, inventoryitem.FieldUserID)
	}
	if m.item != nil {
		fields = append(fields, inventoryitem.FieldItemID)
	}
	if m.received_from_id != nil {
		fields = append(fields, inventoryitem.FieldReceivedFromID)
	}
	if m.obtained_at != nil {
		fields = append(fields, inventoryitem.FieldObtainedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryitem.FieldUserID:
		return m.UserID()
	case inventoryitem.FieldItemID:
		return m.ItemID()
	case inventoryitem.FieldReceivedFromID:
		return m.ReceivedFromID()
	case inventoryitem.FieldObtainedAt:
		return m.ObtainedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryitem.FieldUserID:
		return m.OldUserID(ctx)
	case inventoryitem.FieldItemID:
		return m.OldItemID(ctx)
	case inventoryitem.FieldReceivedFromID:
		return m.OldReceivedFromID(ctx)
	case inventoryitem.FieldObtainedAt:
		return m.OldObtainedAt(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryitem.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case inventoryitem.FieldItemID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case inventoryitem.FieldReceivedFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceivedFromID(v)
		return nil
	case inventoryitem.FieldObtainedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObtainedAt(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryItemMutation) AddedFields() []string {
	var fields []string
	if m.addreceived_from_id != nil {
		fields = append(fields, inventoryitem.FieldReceivedFromID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case inventoryitem.FieldReceivedFromID:
		return m.AddedReceivedFromID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case inventoryitem.FieldReceivedFromID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReceivedFromID(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryItemMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryItemMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InventoryItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryItemMutation) ResetField(name string) error {
	switch name {
	case inventoryitem.FieldUserID:
		m.ResetUserID()
		return nil
	case inventoryitem.FieldItemID:
		m.ResetItemID()
		return nil
	case inventoryitem.FieldReceivedFromID:
		m.ResetReceivedFromID()
		return nil
	case inventoryitem.FieldObtainedAt:
		m.ResetObtainedAt()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, inventoryitem.EdgeUser)
	}
	if m.item != nil {
		edges = append(edges, inventoryitem.EdgeItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryitem.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case inventoryitem.EdgeItem:
		if id := m.item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, inventoryitem.EdgeUser)
	}
	if m.cleareditem {
		edges = append(edges, inventoryitem.EdgeItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryItemMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryitem.EdgeUser:
		return m.cleareduser
	case inventoryitem.EdgeItem:
		return m.cleareditem
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryItemMutation) ClearEdge(name string) error {
	switch name {
	case inventoryitem.EdgeUser:
		m.ClearUser()
		return nil
	case inventoryitem.EdgeItem:
		m.ClearItem()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryItemMutation) ResetEdge(name string) error {
	switch name {
	case inventoryitem.EdgeUser:
		m.ResetUser()
		return nil
	case inventoryitem.EdgeItem:
		m.ResetItem()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem edge %s", name)
}

// MatchMutation represents an operation that mutates the Match nodes in the graph.
type MatchMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	player1_penalty_time         *int
	addplayer1_penalty_time      *int
	player2_penalty_time         *int
	addplayer2_penalty_time      *int
	status                       *match.Status
	result                       *match.Result
	created_at                   *time.Time
	changed_to_current_status_at *time.Time
	clearedFields                map[string]struct{}
	player1                      *int
	clearedplayer1               bool
	player2                      *int
	clearedplayer2               bool
	results                      map[int]struct{}
	removedresults               map[int]struct{}
	clearedresults               bool
	done                         bool
	oldValue                     func(context.Context) (*Match, error)
	predicates                   []predicate.Match
}

var _ ent.Mutation = (*MatchMutation)(nil)

// matchOption allows management of the mutation configuration using functional options.
type matchOption func(*MatchMutation)

// newMatchMutation creates new mutation for the Match entity.
func newMatchMutation(c config, op Op, opts ...matchOption) *MatchMutation {
	m := &MatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchID sets the ID field of the mutation.
func withMatchID(id int) matchOption {
	return func(m *MatchMutation) {
		var (
			err   error
			once  sync.Once
			value *Match
		)
		m.oldValue = func(ctx context.Context) (*Match, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Match.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatch sets the old Match of the mutation.
func withMatch(node *Match) matchOption {
	return func(m *MatchMutation) {
		m.oldValue = func(context.Context) (*Match, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Match entities.
func (m *MatchMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Match.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlayer1ID sets the "player1_id" field.
func (m *MatchMutation) SetPlayer1ID(i int) {
	m.player1 = &i
}

// Player1ID returns the value of the "player1_id" field in the mutation.
func (m *MatchMutation) Player1ID() (r int, exists bool) {
	v := m.player1
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayer1ID returns the old "player1_id" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldPlayer1ID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayer1ID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayer1ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayer1ID: %w", err)
	}
	return oldValue.Player1ID, nil
}

// ResetPlayer1ID resets all changes to the "player1_id" field.
func (m *MatchMutation) ResetPlayer1ID() {
	m.player1 = nil
}

// SetPlayer2ID sets the "player2_id" field.
func (m *MatchMutation) SetPlayer2ID(i int) {
	m.player2 = &i
}

// Player2ID returns the value of the "player2_id" field in the mutation.
func (m *MatchMutation) Player2ID() (r int, exists bool) {
	v := m.player2
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayer2ID returns the old "player2_id" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldPlayer2ID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayer2ID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayer2ID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayer2ID: %w", err)
	}
	return oldValue.Player2ID, nil
}

// ResetPlayer2ID resets all changes to the "player2_id" field.
func (m *MatchMutation) ResetPlayer2ID() {
	m.player2 = nil
}

// SetPlayer1PenaltyTime sets the "player1_penalty_time" field.
func (m *MatchMutation) SetPlayer1PenaltyTime(i int) {
	m.player1_penalty_time = &i
	m.addplayer1_penalty_time = nil
}

// Player1PenaltyTime returns the value of the "player1_penalty_time" field in the mutation.
func (m *MatchMutation) Player1PenaltyTime() (r int, exists bool) {
	v := m.player1_penalty_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayer1PenaltyTime returns the old "player1_penalty_time" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldPlayer1PenaltyTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayer1PenaltyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayer1PenaltyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayer1PenaltyTime: %w", err)
	}
	return oldValue.Player1PenaltyTime, nil
}

// AddPlayer1PenaltyTime adds i to the "player1_penalty_time" field.
func (m *MatchMutation) AddPlayer1PenaltyTime(i int) {
	if m.addplayer1_penalty_time != nil {
		*m.addplayer1_penalty_time += i
	} else {
		m.addplayer1_penalty_time = &i
	}
}

// AddedPlayer1PenaltyTime returns the value that was added to the "player1_penalty_time" field in this mutation.
func (m *MatchMutation) AddedPlayer1PenaltyTime() (r int, exists bool) {
	v := m.addplayer1_penalty_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayer1PenaltyTime resets all changes to the "player1_penalty_time" field.
func (m *MatchMutation) ResetPlayer1PenaltyTime() {
	m.player1_penalty_time = nil
	m.addplayer1_penalty_time = nil
}

// SetPlayer2PenaltyTime sets the "player2_penalty_time" field.
func (m *MatchMutation) SetPlayer2PenaltyTime(i int) {
	m.player2_penalty_time = &i
	m.addplayer2_penalty_time = nil
}

// Player2PenaltyTime returns the value of the "player2_penalty_time" field in the mutation.
func (m *MatchMutation) Player2PenaltyTime() (r int, exists bool) {
	v := m.player2_penalty_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayer2PenaltyTime returns the old "player2_penalty_time" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldPlayer2PenaltyTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayer2PenaltyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayer2PenaltyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayer2PenaltyTime: %w", err)
	}
	return oldValue.Player2PenaltyTime, nil
}

// AddPlayer2PenaltyTime adds i to the "player2_penalty_time" field.
func (m *MatchMutation) AddPlayer2PenaltyTime(i int) {
	if m.addplayer2_penalty_time != nil {
		*m.addplayer2_penalty_time += i
	} else {
		m.addplayer2_penalty_time = &i
	}
}

// AddedPlayer2PenaltyTime returns the value that was added to the "player2_penalty_time" field in this mutation.
func (m *MatchMutation) AddedPlayer2PenaltyTime() (r int, exists bool) {
	v := m.addplayer2_penalty_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetPlayer2PenaltyTime resets all changes to the "player2_penalty_time" field.
func (m *MatchMutation) ResetPlayer2PenaltyTime() {
	m.player2_penalty_time = nil
	m.addplayer2_penalty_time = nil
}

// SetStatus sets the "status" field.
func (m *MatchMutation) SetStatus(value match.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MatchMutation) Status() (r match.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldStatus(ctx context.Context) (v match.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MatchMutation) ResetStatus() {
	m.status = nil
}

// SetResult sets the "result" field.
func (m *MatchMutation) SetResult(value match.Result) {
	m.result = &value
}

// Result returns the value of the "result" field in the mutation.
func (m *MatchMutation) Result() (r match.Result, exists bool) {
	v := m.result
	if v == nil {
		return
	}
	return *v, true
}

// OldResult returns the old "result" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldResult(ctx context.Context) (v *match.Result, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResult: %w", err)
	}
	return oldValue.Result, nil
}

// ClearResult clears the value of the "result" field.
func (m *MatchMutation) ClearResult() {
	m.result = nil
	m.clearedFields[match.FieldResult] = struct{}{}
}

// ResultCleared returns if the "result" field was cleared in this mutation.
func (m *MatchMutation) ResultCleared() bool {
	_, ok := m.clearedFields[match.FieldResult]
	return ok
}

// ResetResult resets all changes to the "result" field.
func (m *MatchMutation) ResetResult() {
	m.result = nil
	delete(m.clearedFields, match.FieldResult)
}

// SetCreatedAt sets the "created_at" field.
func (m *MatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MatchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetChangedToCurrentStatusAt sets the "changed_to_current_status_at" field.
func (m *MatchMutation) SetChangedToCurrentStatusAt(t time.Time) {
	m.changed_to_current_status_at = &t
}

// ChangedToCurrentStatusAt returns the value of the "changed_to_current_status_at" field in the mutation.
func (m *MatchMutation) ChangedToCurrentStatusAt() (r time.Time, exists bool) {
	v := m.changed_to_current_status_at
	if v == nil {
		return
	}
	return *v, true
}

// OldChangedToCurrentStatusAt returns the old "changed_to_current_status_at" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldChangedToCurrentStatusAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangedToCurrentStatusAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangedToCurrentStatusAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangedToCurrentStatusAt: %w", err)
	}
	return oldValue.ChangedToCurrentStatusAt, nil
}

// ResetChangedToCurrentStatusAt resets all changes to the "changed_to_current_status_at" field.
func (m *MatchMutation) ResetChangedToCurrentStatusAt() {
	m.changed_to_current_status_at = nil
}

// ClearPlayer1 clears the "player1" edge to the User entity.
func (m *MatchMutation) ClearPlayer1() {
	m.clearedplayer1 = true
	m.clearedFields[match.FieldPlayer1ID] = struct{}{}
}

// Player1Cleared reports if the "player1" edge to the User entity was cleared.
func (m *MatchMutation) Player1Cleared() bool {
	return m.clearedplayer1
}

// Player1IDs returns the "player1" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// Player1ID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) Player1IDs() (ids []int) {
	if id := m.player1; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer1 resets all changes to the "player1" edge.
func (m *MatchMutation) ResetPlayer1() {
	m.player1 = nil
	m.clearedplayer1 = false
}

// ClearPlayer2 clears the "player2" edge to the User entity.
func (m *MatchMutation) ClearPlayer2() {
	m.clearedplayer2 = true
	m.clearedFields[match.FieldPlayer2ID] = struct{}{}
}

// Player2Cleared reports if the "player2" edge to the User entity was cleared.
func (m *MatchMutation) Player2Cleared() bool {
	return m.clearedplayer2
}

// Player2IDs returns the "player2" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// Player2ID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) Player2IDs() (ids []int) {
	if id := m.player2; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer2 resets all changes to the "player2" edge.
func (m *MatchMutation) ResetPlayer2() {
	m.player2 = nil
	m.clearedplayer2 = false
}

// AddResultIDs adds the "results" edge to the PlayerMatchResult entity by ids.
func (m *MatchMutation) AddResultIDs(ids ...int) {
	if m.results == nil {
		m.results = make(map[int]struct{})
	}
	for i := range ids {
		m.results[ids[i]] = struct{}{}
	}
}

// ClearResults clears the "results" edge to the PlayerMatchResult entity.
func (m *MatchMutation) ClearResults() {
	m.clearedresults = true
}

// ResultsCleared reports if the "results" edge to the PlayerMatchResult entity was cleared.
func (m *MatchMutation) ResultsCleared() bool {
	return m.clearedresults
}

// RemoveResultIDs removes the "results" edge to the PlayerMatchResult entity by IDs.
func (m *MatchMutation) RemoveResultIDs(ids ...int) {
	if m.removedresults == nil {
		m.removedresults = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.results, ids[i])
		m.removedresults[ids[i]] = struct{}{}
	}
}

// RemovedResults returns the removed IDs of the "results" edge to the PlayerMatchResult entity.
func (m *MatchMutation) RemovedResultsIDs() (ids []int) {
	for id := range m.removedresults {
		ids = append(ids, id)
	}
	return
}

// ResultsIDs returns the "results" edge IDs in the mutation.
func (m *MatchMutation) ResultsIDs() (ids []int) {
	for id := range m.results {
		ids = append(ids, id)
	}
	return
}

// ResetResults resets all changes to the "results" edge.
func (m *MatchMutation) ResetResults() {
	m.results = nil
	m.clearedresults = false
	m.removedresults = nil
}

// Where appends a list predicates to the MatchMutation builder.
func (m *MatchMutation) Where(ps ...predicate.Match) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Match, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Match).
func (m *MatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.player1 != nil {
		fields = append(fields, match.FieldPlayer1ID)
	}
	if m.player2 != nil {
		fields = append(fields, match.FieldPlayer2ID)
	}
	if m.player1_penalty_time != nil {
		fields = append(fields, match.FieldPlayer1PenaltyTime)
	}
	if m.player2_penalty_time != nil {
		fields = append(fields, match.FieldPlayer2PenaltyTime)
	}
	if m.status != nil {
		fields = append(fields, match.FieldStatus)
	}
	if m.result != nil {
		fields = append(fields, match.FieldResult)
	}
	if m.created_at != nil {
		fields = append(fields, match.FieldCreatedAt)
	}
	if m.changed_to_current_status_at != nil {
		fields = append(fields, match.FieldChangedToCurrentStatusAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case match.FieldPlayer1ID:
		return m.Player1ID()
	case match.FieldPlayer2ID:
		return m.Player2ID()
	case match.FieldPlayer1PenaltyTime:
		return m.Player1PenaltyTime()
	case match.FieldPlayer2PenaltyTime:
		return m.Player2PenaltyTime()
	case match.FieldStatus:
		return m.Status()
	case match.FieldResult:
		return m.Result()
	case match.FieldCreatedAt:
		return m.CreatedAt()
	case match.FieldChangedToCurrentStatusAt:
		return m.ChangedToCurrentStatusAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case match.FieldPlayer1ID:
		return m.OldPlayer1ID(ctx)
	case match.FieldPlayer2ID:
		return m.OldPlayer2ID(ctx)
	case match.FieldPlayer1PenaltyTime:
		return m.OldPlayer1PenaltyTime(ctx)
	case match.FieldPlayer2PenaltyTime:
		return m.OldPlayer2PenaltyTime(ctx)
	case match.FieldStatus:
		return m.OldStatus(ctx)
	case match.FieldResult:
		return m.OldResult(ctx)
	case match.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case match.FieldChangedToCurrentStatusAt:
		return m.OldChangedToCurrentStatusAt(ctx)
	}
	return nil, fmt.Errorf("unknown Match field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case match.FieldPlayer1ID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayer1ID(v)
		return nil
	case match.FieldPlayer2ID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayer2ID(v)
		return nil
	case match.FieldPlayer1PenaltyTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayer1PenaltyTime(v)
		return nil
	case match.FieldPlayer2PenaltyTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayer2PenaltyTime(v)
		return nil
	case match.FieldStatus:
		v, ok := value.(match.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case match.FieldResult:
		v, ok := value.(match.Result)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResult(v)
		return nil
	case match.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case match.FieldChangedToCurrentStatusAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangedToCurrentStatusAt(v)
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchMutation) AddedFields() []string {
	var fields []string
	if m.addplayer1_penalty_time != nil {
		fields = append(fields, match.FieldPlayer1PenaltyTime)
	}
	if m.addplayer2_penalty_time != nil {
		fields = append(fields, match.FieldPlayer2PenaltyTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case match.FieldPlayer1PenaltyTime:
		return m.AddedPlayer1PenaltyTime()
	case match.FieldPlayer2PenaltyTime:
		return m.AddedPlayer2PenaltyTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case match.FieldPlayer1PenaltyTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayer1PenaltyTime(v)
		return nil
	case match.FieldPlayer2PenaltyTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPlayer2PenaltyTime(v)
		return nil
	}
	return fmt.Errorf("unknown Match numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(match.FieldResult) {
		fields = append(fields, match.FieldResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchMutation) ClearField(name string) error {
	switch name {
	case match.FieldResult:
		m.ClearResult()
		return nil
	}
	return fmt.Errorf("unknown Match nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchMutation) ResetField(name string) error {
	switch name {
	case match.FieldPlayer1ID:
		m.ResetPlayer1ID()
		return nil
	case match.FieldPlayer2ID:
		m.ResetPlayer2ID()
		return nil
	case match.FieldPlayer1PenaltyTime:
		m.ResetPlayer1PenaltyTime()
		return nil
	case match.FieldPlayer2PenaltyTime:
		m.ResetPlayer2PenaltyTime()
		return nil
	case match.FieldStatus:
		m.ResetStatus()
		return nil
	case match.FieldResult:
		m.ResetResult()
		return nil
	case match.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case match.FieldChangedToCurrentStatusAt:
		m.ResetChangedToCurrentStatusAt()
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.player1 != nil {
		edges = append(edges, match.EdgePlayer1)
	}
	if m.player2 != nil {
		edges = append(edges, match.EdgePlayer2)
	}
	if m.results != nil {
		edges = append(edges, match.EdgeResults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case match.EdgePlayer1:
		if id := m.player1; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgePlayer2:
		if id := m.player2; id != nil {
			return []ent.Value{*id}
		}
	case match.EdgeResults:
		ids := make([]ent.Value, 0, len(m.results))
		for id := range m.results {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedresults != nil {
		edges = append(edges, match.EdgeResults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeResults:
		ids := make([]ent.Value, 0, len(m.removedresults))
		for id := range m.removedresults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplayer1 {
		edges = append(edges, match.EdgePlayer1)
	}
	if m.clearedplayer2 {
		edges = append(edges, match.EdgePlayer2)
	}
	if m.clearedresults {
		edges = append(edges, match.EdgeResults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchMutation) EdgeCleared(name string) bool {
	switch name {
	case match.EdgePlayer1:
		return m.clearedplayer1
	case match.EdgePlayer2:
		return m.clearedplayer2
	case match.EdgeResults:
		return m.clearedresults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchMutation) ClearEdge(name string) error {
	switch name {
	case match.EdgePlayer1:
		m.ClearPlayer1()
		return nil
	case match.EdgePlayer2:
		m.ClearPlayer2()
		return nil
	}
	return fmt.Errorf("unknown Match unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchMutation) ResetEdge(name string) error {
	switch name {
	case match.EdgePlayer1:
		m.ResetPlayer1()
		return nil
	case match.EdgePlayer2:
		m.ResetPlayer2()
		return nil
	case match.EdgeResults:
		m.ResetResults()
		return nil
	}
	return fmt.Errorf("unknown Match edge %s", name)
}

// PlayerMatchResultMutation represents an operation that mutates the PlayerMatchResult nodes in the graph.
type PlayerMatchResultMutation struct {
	config
	op            Op
	typ           string
	id            *int
	score         *int
	addscore      *int
	is_retried    *bool
	created_at    *time.Time
	clearedFields map[string]struct{}
	match         *int
	clearedmatch  bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*PlayerMatchResult, error)
	predicates    []predicate.PlayerMatchResult
}

var _ ent.Mutation = (*PlayerMatchResultMutation)(nil)

// playermatchresultOption allows management of the mutation configuration using functional options.
type playermatchresultOption func(*PlayerMatchResultMutation)

// newPlayerMatchResultMutation creates new mutation for the PlayerMatchResult entity.
func newPlayerMatchResultMutation(c config, op Op, opts ...playermatchresultOption) *PlayerMatchResultMutation {
	m := &PlayerMatchResultMutation{
		config:        c,
		op:            op,
		typ:           TypePlayerMatchResult,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerMatchResultID sets the ID field of the mutation.
func withPlayerMatchResultID(id int) playermatchresultOption {
	return func(m *PlayerMatchResultMutation) {
		var (
			err   error
			once  sync.Once
			value *PlayerMatchResult
		)
		m.oldValue = func(ctx context.Context) (*PlayerMatchResult, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlayerMatchResult.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayerMatchResult sets the old PlayerMatchResult of the mutation.
func withPlayerMatchResult(node *PlayerMatchResult) playermatchresultOption {
	return func(m *PlayerMatchResultMutation) {
		m.oldValue = func(context.Context) (*PlayerMatchResult, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMatchResultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMatchResultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlayerMatchResult entities.
func (m *PlayerMatchResultMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMatchResultMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerMatchResultMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlayerMatchResult.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMatchID sets the "match_id" field.
func (m *PlayerMatchResultMutation) SetMatchID(i int) {
	m.match = &i
}

// MatchID returns the value of the "match_id" field in the mutation.
func (m *PlayerMatchResultMutation) MatchID() (r int, exists bool) {
	v := m.match
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchID returns the old "match_id" field's value of the PlayerMatchResult entity.
// If the PlayerMatchResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMatchResultMutation) OldMatchID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchID: %w", err)
	}
	return oldValue.MatchID, nil
}

// ResetMatchID resets all changes to the "match_id" field.
func (m *PlayerMatchResultMutation) ResetMatchID() {
	m.match = nil
}

// SetPlayerID sets the "player_id" field.
func (m *PlayerMatchResultMutation) SetPlayerID(i int) {
	m.user = &i
}

// PlayerID returns the value of the "player_id" field in the mutation.
func (m *PlayerMatchResultMutation) PlayerID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerID returns the old "player_id" field's value of the PlayerMatchResult entity.
// If the PlayerMatchResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMatchResultMutation) OldPlayerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerID: %w", err)
	}
	return oldValue.PlayerID, nil
}

// ResetPlayerID resets all changes to the "player_id" field.
func (m *PlayerMatchResultMutation) ResetPlayerID() {
	m.user = nil
}

// SetScore sets the "score" field.
func (m *PlayerMatchResultMutation) SetScore(i int) {
	m.score = &i
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *PlayerMatchResultMutation) Score() (r int, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the PlayerMatchResult entity.
// If the PlayerMatchResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMatchResultMutation) OldScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds i to the "score" field.
func (m *PlayerMatchResultMutation) AddScore(i int) {
	if m.addscore != nil {
		*m.addscore += i
	} else {
		m.addscore = &i
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *PlayerMatchResultMutation) AddedScore() (r int, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *PlayerMatchResultMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetIsRetried sets the "is_retried" field.
func (m *PlayerMatchResultMutation) SetIsRetried(b bool) {
	m.is_retried = &b
}

// IsRetried returns the value of the "is_retried" field in the mutation.
func (m *PlayerMatchResultMutation) IsRetried() (r bool, exists bool) {
	v := m.is_retried
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRetried returns the old "is_retried" field's value of the PlayerMatchResult entity.
// If the PlayerMatchResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMatchResultMutation) OldIsRetried(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRetried is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRetried requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRetried: %w", err)
	}
	return oldValue.IsRetried, nil
}

// ResetIsRetried resets all changes to the "is_retried" field.
func (m *PlayerMatchResultMutation) ResetIsRetried() {
	m.is_retried = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlayerMatchResultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlayerMatchResultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlayerMatchResult entity.
// If the PlayerMatchResult object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMatchResultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlayerMatchResultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *PlayerMatchResultMutation) ClearMatch() {
	m.clearedmatch = true
	m.clearedFields[playermatchresult.FieldMatchID] = struct{}{}
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *PlayerMatchResultMutation) MatchCleared() bool {
	return m.clearedmatch
}

// MatchIDs returns the "match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MatchID instead. It exists only for internal usage by the builders.
func (m *PlayerMatchResultMutation) MatchIDs() (ids []int) {
	if id := m.match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *PlayerMatchResultMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *PlayerMatchResultMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *PlayerMatchResultMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[playermatchresult.FieldPlayerID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PlayerMatchResultMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *PlayerMatchResultMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PlayerMatchResultMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PlayerMatchResultMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PlayerMatchResultMutation builder.
func (m *PlayerMatchResultMutation) Where(ps ...predicate.PlayerMatchResult) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerMatchResultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerMatchResultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlayerMatchResult, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerMatchResultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerMatchResultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlayerMatchResult).
func (m *PlayerMatchResultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMatchResultMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.match != nil {
		fields = append(fields, playermatchresult.FieldMatchID)
	}
	if m.user != nil {
		fields = append(fields, playermatchresult.FieldPlayerID)
	}
	if m.score != nil {
		fields = append(fields, playermatchresult.FieldScore)
	}
	if m.is_retried != nil {
		fields = append(fields, playermatchresult.FieldIsRetried)
	}
	if m.created_at != nil {
		fields = append(fields, playermatchresult.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMatchResultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playermatchresult.FieldMatchID:
		return m.MatchID()
	case playermatchresult.FieldPlayerID:
		return m.PlayerID()
	case playermatchresult.FieldScore:
		return m.Score()
	case playermatchresult.FieldIsRetried:
		return m.IsRetried()
	case playermatchresult.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMatchResultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playermatchresult.FieldMatchID:
		return m.OldMatchID(ctx)
	case playermatchresult.FieldPlayerID:
		return m.OldPlayerID(ctx)
	case playermatchresult.FieldScore:
		return m.OldScore(ctx)
	case playermatchresult.FieldIsRetried:
		return m.OldIsRetried(ctx)
	case playermatchresult.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PlayerMatchResult field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMatchResultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playermatchresult.FieldMatchID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchID(v)
		return nil
	case playermatchresult.FieldPlayerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerID(v)
		return nil
	case playermatchresult.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case playermatchresult.FieldIsRetried:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRetried(v)
		return nil
	case playermatchresult.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerMatchResult field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMatchResultMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, playermatchresult.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMatchResultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case playermatchresult.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMatchResultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case playermatchresult.FieldScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerMatchResult numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMatchResultMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMatchResultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMatchResultMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlayerMatchResult nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMatchResultMutation) ResetField(name string) error {
	switch name {
	case playermatchresult.FieldMatchID:
		m.ResetMatchID()
		return nil
	case playermatchresult.FieldPlayerID:
		m.ResetPlayerID()
		return nil
	case playermatchresult.FieldScore:
		m.ResetScore()
		return nil
	case playermatchresult.FieldIsRetried:
		m.ResetIsRetried()
		return nil
	case playermatchresult.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PlayerMatchResult field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMatchResultMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.match != nil {
		edges = append(edges, playermatchresult.EdgeMatch)
	}
	if m.user != nil {
		edges = append(edges, playermatchresult.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMatchResultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playermatchresult.EdgeMatch:
		if id := m.match; id != nil {
			return []ent.Value{*id}
		}
	case playermatchresult.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMatchResultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMatchResultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMatchResultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmatch {
		edges = append(edges, playermatchresult.EdgeMatch)
	}
	if m.cleareduser {
		edges = append(edges, playermatchresult.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMatchResultMutation) EdgeCleared(name string) bool {
	switch name {
	case playermatchresult.EdgeMatch:
		return m.clearedmatch
	case playermatchresult.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMatchResultMutation) ClearEdge(name string) error {
	switch name {
	case playermatchresult.EdgeMatch:
		m.ClearMatch()
		return nil
	case playermatchresult.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PlayerMatchResult unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMatchResultMutation) ResetEdge(name string) error {
	switch name {
	case playermatchresult.EdgeMatch:
		m.ResetMatch()
		return nil
	case playermatchresult.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PlayerMatchResult edge %s", name)
}

// StatisticMutation represents an operation that mutates the Statistic nodes in the graph.
type StatisticMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_type                *statistic.Type
	period               *int
	addperiod            *int
	xp                   *int
	addxp                *int
	match_count          *int
	addmatch_count       *int
	wins_count           *int
	addwins_count        *int
	loses_count          *int
	addloses_count       *int
	draws_count          *int
	adddraws_count       *int
	result_time          *int
	addresult_time       *int
	retry_time           *int
	addretry_time        *int
	retry_count          *int
	addretry_count       *int
	best_result_time     *int
	addbest_result_time  *int
	best_retry_count     *int
	addbest_retry_count  *int
	best_match_time      *int
	addbest_match_time   *int
	worst_result_time    *int
	addworst_result_time *int
	worst_retry_count    *int
	addworst_retry_count *int
	worst_match_time     *int
	addworst_match_time  *int
	max_win_streak       *int
	addmax_win_streak    *int
	max_lose_streak      *int
	addmax_lose_streak   *int
	max_login_streak     *int
	addmax_login_streak  *int
	search_score         *int
	addsearch_score      *int
	created_at           *time.Time
	clearedFields        map[string]struct{}
	user                 *int
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Statistic, error)
	predicates           []predicate.Statistic
}

var _ ent.Mutation = (*StatisticMutation)(nil)

// statisticOption allows management of the mutation configuration using functional options.
type statisticOption func(*StatisticMutation)

// newStatisticMutation creates new mutation for the Statistic entity.
func newStatisticMutation(c config, op Op, opts ...statisticOption) *StatisticMutation {
	m := &StatisticMutation{
		config:        c,
		op:            op,
		typ:           TypeStatistic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatisticID sets the ID field of the mutation.
func withStatisticID(id int) statisticOption {
	return func(m *StatisticMutation) {
		var (
			err   error
			once  sync.Once
			value *Statistic
		)
		m.oldValue = func(ctx context.Context) (*Statistic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statistic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatistic sets the old Statistic of the mutation.
func withStatistic(node *Statistic) statisticOption {
	return func(m *StatisticMutation) {
		m.oldValue = func(context.Context) (*Statistic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatisticMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatisticMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Statistic entities.
func (m *StatisticMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatisticMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StatisticMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Statistic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *StatisticMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StatisticMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StatisticMutation) ResetUserID() {
	m.user = nil
}

// SetType sets the "type" field.
func (m *StatisticMutation) SetType(s statistic.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StatisticMutation) GetType() (r statistic.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldType(ctx context.Context) (v statistic.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StatisticMutation) ResetType() {
	m._type = nil
}

// SetPeriod sets the "period" field.
func (m *StatisticMutation) SetPeriod(i int) {
	m.period = &i
	m.addperiod = nil
}

// Period returns the value of the "period" field in the mutation.
func (m *StatisticMutation) Period() (r int, exists bool) {
	v := m.period
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriod returns the old "period" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldPeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriod: %w", err)
	}
	return oldValue.Period, nil
}

// AddPeriod adds i to the "period" field.
func (m *StatisticMutation) AddPeriod(i int) {
	if m.addperiod != nil {
		*m.addperiod += i
	} else {
		m.addperiod = &i
	}
}

// AddedPeriod returns the value that was added to the "period" field in this mutation.
func (m *StatisticMutation) AddedPeriod() (r int, exists bool) {
	v := m.addperiod
	if v == nil {
		return
	}
	return *v, true
}

// ResetPeriod resets all changes to the "period" field.
func (m *StatisticMutation) ResetPeriod() {
	m.period = nil
	m.addperiod = nil
}

// SetXp sets the "xp" field.
func (m *StatisticMutation) SetXp(i int) {
	m.xp = &i
	m.addxp = nil
}

// Xp returns the value of the "xp" field in the mutation.
func (m *StatisticMutation) Xp() (r int, exists bool) {
	v := m.xp
	if v == nil {
		return
	}
	return *v, true
}

// OldXp returns the old "xp" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldXp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldXp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldXp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldXp: %w", err)
	}
	return oldValue.Xp, nil
}

// AddXp adds i to the "xp" field.
func (m *StatisticMutation) AddXp(i int) {
	if m.addxp != nil {
		*m.addxp += i
	} else {
		m.addxp = &i
	}
}

// AddedXp returns the value that was added to the "xp" field in this mutation.
func (m *StatisticMutation) AddedXp() (r int, exists bool) {
	v := m.addxp
	if v == nil {
		return
	}
	return *v, true
}

// ResetXp resets all changes to the "xp" field.
func (m *StatisticMutation) ResetXp() {
	m.xp = nil
	m.addxp = nil
}

// SetMatchCount sets the "match_count" field.
func (m *StatisticMutation) SetMatchCount(i int) {
	m.match_count = &i
	m.addmatch_count = nil
}

// MatchCount returns the value of the "match_count" field in the mutation.
func (m *StatisticMutation) MatchCount() (r int, exists bool) {
	v := m.match_count
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchCount returns the old "match_count" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldMatchCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchCount: %w", err)
	}
	return oldValue.MatchCount, nil
}

// AddMatchCount adds i to the "match_count" field.
func (m *StatisticMutation) AddMatchCount(i int) {
	if m.addmatch_count != nil {
		*m.addmatch_count += i
	} else {
		m.addmatch_count = &i
	}
}

// AddedMatchCount returns the value that was added to the "match_count" field in this mutation.
func (m *StatisticMutation) AddedMatchCount() (r int, exists bool) {
	v := m.addmatch_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetMatchCount resets all changes to the "match_count" field.
func (m *StatisticMutation) ResetMatchCount() {
	m.match_count = nil
	m.addmatch_count = nil
}

// SetWinsCount sets the "wins_count" field.
func (m *StatisticMutation) SetWinsCount(i int) {
	m.wins_count = &i
	m.addwins_count = nil
}

// WinsCount returns the value of the "wins_count" field in the mutation.
func (m *StatisticMutation) WinsCount() (r int, exists bool) {
	v := m.wins_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWinsCount returns the old "wins_count" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldWinsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWinsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWinsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWinsCount: %w", err)
	}
	return oldValue.WinsCount, nil
}

// AddWinsCount adds i to the "wins_count" field.
func (m *StatisticMutation) AddWinsCount(i int) {
	if m.addwins_count != nil {
		*m.addwins_count += i
	} else {
		m.addwins_count = &i
	}
}

// AddedWinsCount returns the value that was added to the "wins_count" field in this mutation.
func (m *StatisticMutation) AddedWinsCount() (r int, exists bool) {
	v := m.addwins_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWinsCount resets all changes to the "wins_count" field.
func (m *StatisticMutation) ResetWinsCount() {
	m.wins_count = nil
	m.addwins_count = nil
}

// SetLosesCount sets the "loses_count" field.
func (m *StatisticMutation) SetLosesCount(i int) {
	m.loses_count = &i
	m.addloses_count = nil
}

// LosesCount returns the value of the "loses_count" field in the mutation.
func (m *StatisticMutation) LosesCount() (r int, exists bool) {
	v := m.loses_count
	if v == nil {
		return
	}
	return *v, true
}

// OldLosesCount returns the old "loses_count" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldLosesCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLosesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLosesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLosesCount: %w", err)
	}
	return oldValue.LosesCount, nil
}

// AddLosesCount adds i to the "loses_count" field.
func (m *StatisticMutation) AddLosesCount(i int) {
	if m.addloses_count != nil {
		*m.addloses_count += i
	} else {
		m.addloses_count = &i
	}
}

// AddedLosesCount returns the value that was added to the "loses_count" field in this mutation.
func (m *StatisticMutation) AddedLosesCount() (r int, exists bool) {
	v := m.addloses_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetLosesCount resets all changes to the "loses_count" field.
func (m *StatisticMutation) ResetLosesCount() {
	m.loses_count = nil
	m.addloses_count = nil
}

// SetDrawsCount sets the "draws_count" field.
func (m *StatisticMutation) SetDrawsCount(i int) {
	m.draws_count = &i
	m.adddraws_count = nil
}

// DrawsCount returns the value of the "draws_count" field in the mutation.
func (m *StatisticMutation) DrawsCount() (r int, exists bool) {
	v := m.draws_count
	if v == nil {
		return
	}
	return *v, true
}

// OldDrawsCount returns the old "draws_count" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldDrawsCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrawsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrawsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrawsCount: %w", err)
	}
	return oldValue.DrawsCount, nil
}

// AddDrawsCount adds i to the "draws_count" field.
func (m *StatisticMutation) AddDrawsCount(i int) {
	if m.adddraws_count != nil {
		*m.adddraws_count += i
	} else {
		m.adddraws_count = &i
	}
}

// AddedDrawsCount returns the value that was added to the "draws_count" field in this mutation.
func (m *StatisticMutation) AddedDrawsCount() (r int, exists bool) {
	v := m.adddraws_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetDrawsCount resets all changes to the "draws_count" field.
func (m *StatisticMutation) ResetDrawsCount() {
	m.draws_count = nil
	m.adddraws_count = nil
}

// SetResultTime sets the "result_time" field.
func (m *StatisticMutation) SetResultTime(i int) {
	m.result_time = &i
	m.addresult_time = nil
}

// ResultTime returns the value of the "result_time" field in the mutation.
func (m *StatisticMutation) ResultTime() (r int, exists bool) {
	v := m.result_time
	if v == nil {
		return
	}
	return *v, true
}

// OldResultTime returns the old "result_time" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldResultTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultTime: %w", err)
	}
	return oldValue.ResultTime, nil
}

// AddResultTime adds i to the "result_time" field.
func (m *StatisticMutation) AddResultTime(i int) {
	if m.addresult_time != nil {
		*m.addresult_time += i
	} else {
		m.addresult_time = &i
	}
}

// AddedResultTime returns the value that was added to the "result_time" field in this mutation.
func (m *StatisticMutation) AddedResultTime() (r int, exists bool) {
	v := m.addresult_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetResultTime resets all changes to the "result_time" field.
func (m *StatisticMutation) ResetResultTime() {
	m.result_time = nil
	m.addresult_time = nil
}

// SetRetryTime sets the "retry_time" field.
func (m *StatisticMutation) SetRetryTime(i int) {
	m.retry_time = &i
	m.addretry_time = nil
}

// RetryTime returns the value of the "retry_time" field in the mutation.
func (m *StatisticMutation) RetryTime() (r int, exists bool) {
	v := m.retry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryTime returns the old "retry_time" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldRetryTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryTime: %w", err)
	}
	return oldValue.RetryTime, nil
}

// AddRetryTime adds i to the "retry_time" field.
func (m *StatisticMutation) AddRetryTime(i int) {
	if m.addretry_time != nil {
		*m.addretry_time += i
	} else {
		m.addretry_time = &i
	}
}

// AddedRetryTime returns the value that was added to the "retry_time" field in this mutation.
func (m *StatisticMutation) AddedRetryTime() (r int, exists bool) {
	v := m.addretry_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryTime resets all changes to the "retry_time" field.
func (m *StatisticMutation) ResetRetryTime() {
	m.retry_time = nil
	m.addretry_time = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *StatisticMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *StatisticMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *StatisticMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *StatisticMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *StatisticMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetBestResultTime sets the "best_result_time" field.
func (m *StatisticMutation) SetBestResultTime(i int) {
	m.best_result_time = &i
	m.addbest_result_time = nil
}

// BestResultTime returns the value of the "best_result_time" field in the mutation.
func (m *StatisticMutation) BestResultTime() (r int, exists bool) {
	v := m.best_result_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBestResultTime returns the old "best_result_time" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldBestResultTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBestResultTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBestResultTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBestResultTime: %w", err)
	}
	return oldValue.BestResultTime, nil
}

// AddBestResultTime adds i to the "best_result_time" field.
func (m *StatisticMutation) AddBestResultTime(i int) {
	if m.addbest_result_time != nil {
		*m.addbest_result_time += i
	} else {
		m.addbest_result_time = &i
	}
}

// AddedBestResultTime returns the value that was added to the "best_result_time" field in this mutation.
func (m *StatisticMutation) AddedBestResultTime() (r int, exists bool) {
	v := m.addbest_result_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetBestResultTime resets all changes to the "best_result_time" field.
func (m *StatisticMutation) ResetBestResultTime() {
	m.best_result_time = nil
	m.addbest_result_time = nil
}

// SetBestRetryCount sets the "best_retry_count" field.
func (m *StatisticMutation) SetBestRetryCount(i int) {
	m.best_retry_count = &i
	m.addbest_retry_count = nil
}

// BestRetryCount returns the value of the "best_retry_count" field in the mutation.
func (m *StatisticMutation) BestRetryCount() (r int, exists bool) {
	v := m.best_retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldBestRetryCount returns the old "best_retry_count" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldBestRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBestRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBestRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBestRetryCount: %w", err)
	}
	return oldValue.BestRetryCount, nil
}

// AddBestRetryCount adds i to the "best_retry_count" field.
func (m *StatisticMutation) AddBestRetryCount(i int) {
	if m.addbest_retry_count != nil {
		*m.addbest_retry_count += i
	} else {
		m.addbest_retry_count = &i
	}
}

// AddedBestRetryCount returns the value that was added to the "best_retry_count" field in this mutation.
func (m *StatisticMutation) AddedBestRetryCount() (r int, exists bool) {
	v := m.addbest_retry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetBestRetryCount resets all changes to the "best_retry_count" field.
func (m *StatisticMutation) ResetBestRetryCount() {
	m.best_retry_count = nil
	m.addbest_retry_count = nil
}

// SetBestMatchTime sets the "best_match_time" field.
func (m *StatisticMutation) SetBestMatchTime(i int) {
	m.best_match_time = &i
	m.addbest_match_time = nil
}

// BestMatchTime returns the value of the "best_match_time" field in the mutation.
func (m *StatisticMutation) BestMatchTime() (r int, exists bool) {
	v := m.best_match_time
	if v == nil {
		return
	}
	return *v, true
}

// OldBestMatchTime returns the old "best_match_time" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldBestMatchTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBestMatchTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBestMatchTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBestMatchTime: %w", err)
	}
	return oldValue.BestMatchTime, nil
}

// AddBestMatchTime adds i to the "best_match_time" field.
func (m *StatisticMutation) AddBestMatchTime(i int) {
	if m.addbest_match_time != nil {
		*m.addbest_match_time += i
	} else {
		m.addbest_match_time = &i
	}
}

// AddedBestMatchTime returns the value that was added to the "best_match_time" field in this mutation.
func (m *StatisticMutation) AddedBestMatchTime() (r int, exists bool) {
	v := m.addbest_match_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetBestMatchTime resets all changes to the "best_match_time" field.
func (m *StatisticMutation) ResetBestMatchTime() {
	m.best_match_time = nil
	m.addbest_match_time = nil
}

// SetWorstResultTime sets the "worst_result_time" field.
func (m *StatisticMutation) SetWorstResultTime(i int) {
	m.worst_result_time = &i
	m.addworst_result_time = nil
}

// WorstResultTime returns the value of the "worst_result_time" field in the mutation.
func (m *StatisticMutation) WorstResultTime() (r int, exists bool) {
	v := m.worst_result_time
	if v == nil {
		return
	}
	return *v, true
}

// OldWorstResultTime returns the old "worst_result_time" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldWorstResultTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorstResultTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorstResultTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorstResultTime: %w", err)
	}
	return oldValue.WorstResultTime, nil
}

// AddWorstResultTime adds i to the "worst_result_time" field.
func (m *StatisticMutation) AddWorstResultTime(i int) {
	if m.addworst_result_time != nil {
		*m.addworst_result_time += i
	} else {
		m.addworst_result_time = &i
	}
}

// AddedWorstResultTime returns the value that was added to the "worst_result_time" field in this mutation.
func (m *StatisticMutation) AddedWorstResultTime() (r int, exists bool) {
	v := m.addworst_result_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorstResultTime resets all changes to the "worst_result_time" field.
func (m *StatisticMutation) ResetWorstResultTime() {
	m.worst_result_time = nil
	m.addworst_result_time = nil
}

// SetWorstRetryCount sets the "worst_retry_count" field.
func (m *StatisticMutation) SetWorstRetryCount(i int) {
	m.worst_retry_count = &i
	m.addworst_retry_count = nil
}

// WorstRetryCount returns the value of the "worst_retry_count" field in the mutation.
func (m *StatisticMutation) WorstRetryCount() (r int, exists bool) {
	v := m.worst_retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldWorstRetryCount returns the old "worst_retry_count" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldWorstRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorstRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorstRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorstRetryCount: %w", err)
	}
	return oldValue.WorstRetryCount, nil
}

// AddWorstRetryCount adds i to the "worst_retry_count" field.
func (m *StatisticMutation) AddWorstRetryCount(i int) {
	if m.addworst_retry_count != nil {
		*m.addworst_retry_count += i
	} else {
		m.addworst_retry_count = &i
	}
}

// AddedWorstRetryCount returns the value that was added to the "worst_retry_count" field in this mutation.
func (m *StatisticMutation) AddedWorstRetryCount() (r int, exists bool) {
	v := m.addworst_retry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorstRetryCount resets all changes to the "worst_retry_count" field.
func (m *StatisticMutation) ResetWorstRetryCount() {
	m.worst_retry_count = nil
	m.addworst_retry_count = nil
}

// SetWorstMatchTime sets the "worst_match_time" field.
func (m *StatisticMutation) SetWorstMatchTime(i int) {
	m.worst_match_time = &i
	m.addworst_match_time = nil
}

// WorstMatchTime returns the value of the "worst_match_time" field in the mutation.
func (m *StatisticMutation) WorstMatchTime() (r int, exists bool) {
	v := m.worst_match_time
	if v == nil {
		return
	}
	return *v, true
}

// OldWorstMatchTime returns the old "worst_match_time" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldWorstMatchTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorstMatchTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorstMatchTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorstMatchTime: %w", err)
	}
	return oldValue.WorstMatchTime, nil
}

// AddWorstMatchTime adds i to the "worst_match_time" field.
func (m *StatisticMutation) AddWorstMatchTime(i int) {
	if m.addworst_match_time != nil {
		*m.addworst_match_time += i
	} else {
		m.addworst_match_time = &i
	}
}

// AddedWorstMatchTime returns the value that was added to the "worst_match_time" field in this mutation.
func (m *StatisticMutation) AddedWorstMatchTime() (r int, exists bool) {
	v := m.addworst_match_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorstMatchTime resets all changes to the "worst_match_time" field.
func (m *StatisticMutation) ResetWorstMatchTime() {
	m.worst_match_time = nil
	m.addworst_match_time = nil
}

// SetMaxWinStreak sets the "max_win_streak" field.
func (m *StatisticMutation) SetMaxWinStreak(i int) {
	m.max_win_streak = &i
	m.addmax_win_streak = nil
}

// MaxWinStreak returns the value of the "max_win_streak" field in the mutation.
func (m *StatisticMutation) MaxWinStreak() (r int, exists bool) {
	v := m.max_win_streak
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxWinStreak returns the old "max_win_streak" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldMaxWinStreak(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxWinStreak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxWinStreak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxWinStreak: %w", err)
	}
	return oldValue.MaxWinStreak, nil
}

// AddMaxWinStreak adds i to the "max_win_streak" field.
func (m *StatisticMutation) AddMaxWinStreak(i int) {
	if m.addmax_win_streak != nil {
		*m.addmax_win_streak += i
	} else {
		m.addmax_win_streak = &i
	}
}

// AddedMaxWinStreak returns the value that was added to the "max_win_streak" field in this mutation.
func (m *StatisticMutation) AddedMaxWinStreak() (r int, exists bool) {
	v := m.addmax_win_streak
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxWinStreak resets all changes to the "max_win_streak" field.
func (m *StatisticMutation) ResetMaxWinStreak() {
	m.max_win_streak = nil
	m.addmax_win_streak = nil
}

// SetMaxLoseStreak sets the "max_lose_streak" field.
func (m *StatisticMutation) SetMaxLoseStreak(i int) {
	m.max_lose_streak = &i
	m.addmax_lose_streak = nil
}

// MaxLoseStreak returns the value of the "max_lose_streak" field in the mutation.
func (m *StatisticMutation) MaxLoseStreak() (r int, exists bool) {
	v := m.max_lose_streak
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLoseStreak returns the old "max_lose_streak" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldMaxLoseStreak(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLoseStreak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLoseStreak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLoseStreak: %w", err)
	}
	return oldValue.MaxLoseStreak, nil
}

// AddMaxLoseStreak adds i to the "max_lose_streak" field.
func (m *StatisticMutation) AddMaxLoseStreak(i int) {
	if m.addmax_lose_streak != nil {
		*m.addmax_lose_streak += i
	} else {
		m.addmax_lose_streak = &i
	}
}

// AddedMaxLoseStreak returns the value that was added to the "max_lose_streak" field in this mutation.
func (m *StatisticMutation) AddedMaxLoseStreak() (r int, exists bool) {
	v := m.addmax_lose_streak
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLoseStreak resets all changes to the "max_lose_streak" field.
func (m *StatisticMutation) ResetMaxLoseStreak() {
	m.max_lose_streak = nil
	m.addmax_lose_streak = nil
}

// SetMaxLoginStreak sets the "max_login_streak" field.
func (m *StatisticMutation) SetMaxLoginStreak(i int) {
	m.max_login_streak = &i
	m.addmax_login_streak = nil
}

// MaxLoginStreak returns the value of the "max_login_streak" field in the mutation.
func (m *StatisticMutation) MaxLoginStreak() (r int, exists bool) {
	v := m.max_login_streak
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxLoginStreak returns the old "max_login_streak" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldMaxLoginStreak(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxLoginStreak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxLoginStreak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxLoginStreak: %w", err)
	}
	return oldValue.MaxLoginStreak, nil
}

// AddMaxLoginStreak adds i to the "max_login_streak" field.
func (m *StatisticMutation) AddMaxLoginStreak(i int) {
	if m.addmax_login_streak != nil {
		*m.addmax_login_streak += i
	} else {
		m.addmax_login_streak = &i
	}
}

// AddedMaxLoginStreak returns the value that was added to the "max_login_streak" field in this mutation.
func (m *StatisticMutation) AddedMaxLoginStreak() (r int, exists bool) {
	v := m.addmax_login_streak
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxLoginStreak resets all changes to the "max_login_streak" field.
func (m *StatisticMutation) ResetMaxLoginStreak() {
	m.max_login_streak = nil
	m.addmax_login_streak = nil
}

// SetSearchScore sets the "search_score" field.
func (m *StatisticMutation) SetSearchScore(i int) {
	m.search_score = &i
	m.addsearch_score = nil
}

// SearchScore returns the value of the "search_score" field in the mutation.
func (m *StatisticMutation) SearchScore() (r int, exists bool) {
	v := m.search_score
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchScore returns the old "search_score" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldSearchScore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchScore: %w", err)
	}
	return oldValue.SearchScore, nil
}

// AddSearchScore adds i to the "search_score" field.
func (m *StatisticMutation) AddSearchScore(i int) {
	if m.addsearch_score != nil {
		*m.addsearch_score += i
	} else {
		m.addsearch_score = &i
	}
}

// AddedSearchScore returns the value that was added to the "search_score" field in this mutation.
func (m *StatisticMutation) AddedSearchScore() (r int, exists bool) {
	v := m.addsearch_score
	if v == nil {
		return
	}
	return *v, true
}

// ResetSearchScore resets all changes to the "search_score" field.
func (m *StatisticMutation) ResetSearchScore() {
	m.search_score = nil
	m.addsearch_score = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StatisticMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatisticMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatisticMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *StatisticMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[statistic.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StatisticMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StatisticMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StatisticMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the StatisticMutation builder.
func (m *StatisticMutation) Where(ps ...predicate.Statistic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StatisticMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StatisticMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Statistic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StatisticMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StatisticMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Statistic).
func (m *StatisticMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatisticMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.user != nil {
		fields = append(fields, statistic.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, statistic.FieldType)
	}
	if m.period != nil {
		fields = append(fields, statistic.FieldPeriod)
	}
	if m.xp != nil {
		fields = append(fields, statistic.FieldXp)
	}
	if m.match_count != nil {
		fields = append(fields, statistic.FieldMatchCount)
	}
	if m.wins_count != nil {
		fields = append(fields, statistic.FieldWinsCount)
	}
	if m.loses_count != nil {
		fields = append(fields, statistic.FieldLosesCount)
	}
	if m.draws_count != nil {
		fields = append(fields, statistic.FieldDrawsCount)
	}
	if m.result_time != nil {
		fields = append(fields, statistic.FieldResultTime)
	}
	if m.retry_time != nil {
		fields = append(fields, statistic.FieldRetryTime)
	}
	if m.retry_count != nil {
		fields = append(fields, statistic.FieldRetryCount)
	}
	if m.best_result_time != nil {
		fields = append(fields, statistic.FieldBestResultTime)
	}
	if m.best_retry_count != nil {
		fields = append(fields, statistic.FieldBestRetryCount)
	}
	if m.best_match_time != nil {
		fields = append(fields, statistic.FieldBestMatchTime)
	}
	if m.worst_result_time != nil {
		fields = append(fields, statistic.FieldWorstResultTime)
	}
	if m.worst_retry_count != nil {
		fields = append(fields, statistic.FieldWorstRetryCount)
	}
	if m.worst_match_time != nil {
		fields = append(fields, statistic.FieldWorstMatchTime)
	}
	if m.max_win_streak != nil {
		fields = append(fields, statistic.FieldMaxWinStreak)
	}
	if m.max_lose_streak != nil {
		fields = append(fields, statistic.FieldMaxLoseStreak)
	}
	if m.max_login_streak != nil {
		fields = append(fields, statistic.FieldMaxLoginStreak)
	}
	if m.search_score != nil {
		fields = append(fields, statistic.FieldSearchScore)
	}
	if m.created_at != nil {
		fields = append(fields, statistic.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatisticMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statistic.FieldUserID:
		return m.UserID()
	case statistic.FieldType:
		return m.GetType()
	case statistic.FieldPeriod:
		return m.Period()
	case statistic.FieldXp:
		return m.Xp()
	case statistic.FieldMatchCount:
		return m.MatchCount()
	case statistic.FieldWinsCount:
		return m.WinsCount()
	case statistic.FieldLosesCount:
		return m.LosesCount()
	case statistic.FieldDrawsCount:
		return m.DrawsCount()
	case statistic.FieldResultTime:
		return m.ResultTime()
	case statistic.FieldRetryTime:
		return m.RetryTime()
	case statistic.FieldRetryCount:
		return m.RetryCount()
	case statistic.FieldBestResultTime:
		return m.BestResultTime()
	case statistic.FieldBestRetryCount:
		return m.BestRetryCount()
	case statistic.FieldBestMatchTime:
		return m.BestMatchTime()
	case statistic.FieldWorstResultTime:
		return m.WorstResultTime()
	case statistic.FieldWorstRetryCount:
		return m.WorstRetryCount()
	case statistic.FieldWorstMatchTime:
		return m.WorstMatchTime()
	case statistic.FieldMaxWinStreak:
		return m.MaxWinStreak()
	case statistic.FieldMaxLoseStreak:
		return m.MaxLoseStreak()
	case statistic.FieldMaxLoginStreak:
		return m.MaxLoginStreak()
	case statistic.FieldSearchScore:
		return m.SearchScore()
	case statistic.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatisticMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statistic.FieldUserID:
		return m.OldUserID(ctx)
	case statistic.FieldType:
		return m.OldType(ctx)
	case statistic.FieldPeriod:
		return m.OldPeriod(ctx)
	case statistic.FieldXp:
		return m.OldXp(ctx)
	case statistic.FieldMatchCount:
		return m.OldMatchCount(ctx)
	case statistic.FieldWinsCount:
		return m.OldWinsCount(ctx)
	case statistic.FieldLosesCount:
		return m.OldLosesCount(ctx)
	case statistic.FieldDrawsCount:
		return m.OldDrawsCount(ctx)
	case statistic.FieldResultTime:
		return m.OldResultTime(ctx)
	case statistic.FieldRetryTime:
		return m.OldRetryTime(ctx)
	case statistic.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case statistic.FieldBestResultTime:
		return m.OldBestResultTime(ctx)
	case statistic.FieldBestRetryCount:
		return m.OldBestRetryCount(ctx)
	case statistic.FieldBestMatchTime:
		return m.OldBestMatchTime(ctx)
	case statistic.FieldWorstResultTime:
		return m.OldWorstResultTime(ctx)
	case statistic.FieldWorstRetryCount:
		return m.OldWorstRetryCount(ctx)
	case statistic.FieldWorstMatchTime:
		return m.OldWorstMatchTime(ctx)
	case statistic.FieldMaxWinStreak:
		return m.OldMaxWinStreak(ctx)
	case statistic.FieldMaxLoseStreak:
		return m.OldMaxLoseStreak(ctx)
	case statistic.FieldMaxLoginStreak:
		return m.OldMaxLoginStreak(ctx)
	case statistic.FieldSearchScore:
		return m.OldSearchScore(ctx)
	case statistic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Statistic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatisticMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statistic.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case statistic.FieldType:
		v, ok := value.(statistic.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case statistic.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriod(v)
		return nil
	case statistic.FieldXp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetXp(v)
		return nil
	case statistic.FieldMatchCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchCount(v)
		return nil
	case statistic.FieldWinsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWinsCount(v)
		return nil
	case statistic.FieldLosesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLosesCount(v)
		return nil
	case statistic.FieldDrawsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrawsCount(v)
		return nil
	case statistic.FieldResultTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultTime(v)
		return nil
	case statistic.FieldRetryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryTime(v)
		return nil
	case statistic.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case statistic.FieldBestResultTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBestResultTime(v)
		return nil
	case statistic.FieldBestRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBestRetryCount(v)
		return nil
	case statistic.FieldBestMatchTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBestMatchTime(v)
		return nil
	case statistic.FieldWorstResultTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorstResultTime(v)
		return nil
	case statistic.FieldWorstRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorstRetryCount(v)
		return nil
	case statistic.FieldWorstMatchTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorstMatchTime(v)
		return nil
	case statistic.FieldMaxWinStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxWinStreak(v)
		return nil
	case statistic.FieldMaxLoseStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLoseStreak(v)
		return nil
	case statistic.FieldMaxLoginStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxLoginStreak(v)
		return nil
	case statistic.FieldSearchScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchScore(v)
		return nil
	case statistic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Statistic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatisticMutation) AddedFields() []string {
	var fields []string
	if m.addperiod != nil {
		fields = append(fields, statistic.FieldPeriod)
	}
	if m.addxp != nil {
		fields = append(fields, statistic.FieldXp)
	}
	if m.addmatch_count != nil {
		fields = append(fields, statistic.FieldMatchCount)
	}
	if m.addwins_count != nil {
		fields = append(fields, statistic.FieldWinsCount)
	}
	if m.addloses_count != nil {
		fields = append(fields, statistic.FieldLosesCount)
	}
	if m.adddraws_count != nil {
		fields = append(fields, statistic.FieldDrawsCount)
	}
	if m.addresult_time != nil {
		fields = append(fields, statistic.FieldResultTime)
	}
	if m.addretry_time != nil {
		fields = append(fields, statistic.FieldRetryTime)
	}
	if m.addretry_count != nil {
		fields = append(fields, statistic.FieldRetryCount)
	}
	if m.addbest_result_time != nil {
		fields = append(fields, statistic.FieldBestResultTime)
	}
	if m.addbest_retry_count != nil {
		fields = append(fields, statistic.FieldBestRetryCount)
	}
	if m.addbest_match_time != nil {
		fields = append(fields, statistic.FieldBestMatchTime)
	}
	if m.addworst_result_time != nil {
		fields = append(fields, statistic.FieldWorstResultTime)
	}
	if m.addworst_retry_count != nil {
		fields = append(fields, statistic.FieldWorstRetryCount)
	}
	if m.addworst_match_time != nil {
		fields = append(fields, statistic.FieldWorstMatchTime)
	}
	if m.addmax_win_streak != nil {
		fields = append(fields, statistic.FieldMaxWinStreak)
	}
	if m.addmax_lose_streak != nil {
		fields = append(fields, statistic.FieldMaxLoseStreak)
	}
	if m.addmax_login_streak != nil {
		fields = append(fields, statistic.FieldMaxLoginStreak)
	}
	if m.addsearch_score != nil {
		fields = append(fields, statistic.FieldSearchScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatisticMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statistic.FieldPeriod:
		return m.AddedPeriod()
	case statistic.FieldXp:
		return m.AddedXp()
	case statistic.FieldMatchCount:
		return m.AddedMatchCount()
	case statistic.FieldWinsCount:
		return m.AddedWinsCount()
	case statistic.FieldLosesCount:
		return m.AddedLosesCount()
	case statistic.FieldDrawsCount:
		return m.AddedDrawsCount()
	case statistic.FieldResultTime:
		return m.AddedResultTime()
	case statistic.FieldRetryTime:
		return m.AddedRetryTime()
	case statistic.FieldRetryCount:
		return m.AddedRetryCount()
	case statistic.FieldBestResultTime:
		return m.AddedBestResultTime()
	case statistic.FieldBestRetryCount:
		return m.AddedBestRetryCount()
	case statistic.FieldBestMatchTime:
		return m.AddedBestMatchTime()
	case statistic.FieldWorstResultTime:
		return m.AddedWorstResultTime()
	case statistic.FieldWorstRetryCount:
		return m.AddedWorstRetryCount()
	case statistic.FieldWorstMatchTime:
		return m.AddedWorstMatchTime()
	case statistic.FieldMaxWinStreak:
		return m.AddedMaxWinStreak()
	case statistic.FieldMaxLoseStreak:
		return m.AddedMaxLoseStreak()
	case statistic.FieldMaxLoginStreak:
		return m.AddedMaxLoginStreak()
	case statistic.FieldSearchScore:
		return m.AddedSearchScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatisticMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statistic.FieldPeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPeriod(v)
		return nil
	case statistic.FieldXp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddXp(v)
		return nil
	case statistic.FieldMatchCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMatchCount(v)
		return nil
	case statistic.FieldWinsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWinsCount(v)
		return nil
	case statistic.FieldLosesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLosesCount(v)
		return nil
	case statistic.FieldDrawsCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDrawsCount(v)
		return nil
	case statistic.FieldResultTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResultTime(v)
		return nil
	case statistic.FieldRetryTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryTime(v)
		return nil
	case statistic.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	case statistic.FieldBestResultTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBestResultTime(v)
		return nil
	case statistic.FieldBestRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBestRetryCount(v)
		return nil
	case statistic.FieldBestMatchTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBestMatchTime(v)
		return nil
	case statistic.FieldWorstResultTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorstResultTime(v)
		return nil
	case statistic.FieldWorstRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorstRetryCount(v)
		return nil
	case statistic.FieldWorstMatchTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorstMatchTime(v)
		return nil
	case statistic.FieldMaxWinStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxWinStreak(v)
		return nil
	case statistic.FieldMaxLoseStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLoseStreak(v)
		return nil
	case statistic.FieldMaxLoginStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxLoginStreak(v)
		return nil
	case statistic.FieldSearchScore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSearchScore(v)
		return nil
	}
	return fmt.Errorf("unknown Statistic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatisticMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatisticMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatisticMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statistic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatisticMutation) ResetField(name string) error {
	switch name {
	case statistic.FieldUserID:
		m.ResetUserID()
		return nil
	case statistic.FieldType:
		m.ResetType()
		return nil
	case statistic.FieldPeriod:
		m.ResetPeriod()
		return nil
	case statistic.FieldXp:
		m.ResetXp()
		return nil
	case statistic.FieldMatchCount:
		m.ResetMatchCount()
		return nil
	case statistic.FieldWinsCount:
		m.ResetWinsCount()
		return nil
	case statistic.FieldLosesCount:
		m.ResetLosesCount()
		return nil
	case statistic.FieldDrawsCount:
		m.ResetDrawsCount()
		return nil
	case statistic.FieldResultTime:
		m.ResetResultTime()
		return nil
	case statistic.FieldRetryTime:
		m.ResetRetryTime()
		return nil
	case statistic.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case statistic.FieldBestResultTime:
		m.ResetBestResultTime()
		return nil
	case statistic.FieldBestRetryCount:
		m.ResetBestRetryCount()
		return nil
	case statistic.FieldBestMatchTime:
		m.ResetBestMatchTime()
		return nil
	case statistic.FieldWorstResultTime:
		m.ResetWorstResultTime()
		return nil
	case statistic.FieldWorstRetryCount:
		m.ResetWorstRetryCount()
		return nil
	case statistic.FieldWorstMatchTime:
		m.ResetWorstMatchTime()
		return nil
	case statistic.FieldMaxWinStreak:
		m.ResetMaxWinStreak()
		return nil
	case statistic.FieldMaxLoseStreak:
		m.ResetMaxLoseStreak()
		return nil
	case statistic.FieldMaxLoginStreak:
		m.ResetMaxLoginStreak()
		return nil
	case statistic.FieldSearchScore:
		m.ResetSearchScore()
		return nil
	case statistic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Statistic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatisticMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, statistic.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatisticMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statistic.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatisticMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatisticMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatisticMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, statistic.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatisticMutation) EdgeCleared(name string) bool {
	switch name {
	case statistic.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatisticMutation) ClearEdge(name string) error {
	switch name {
	case statistic.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Statistic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatisticMutation) ResetEdge(name string) error {
	switch name {
	case statistic.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Statistic edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	username                        *string
	email                           *string
	password                        *string
	hardware_id                     *string
	access_level                    *access_level.AccessLevel
	genshin_uid                     *string
	hoyolab_login                   *string
	avatar_url                      *string
	invites_enabled                 *bool
	login_at                        *time.Time
	login_streak                    *int
	addlogin_streak                 *int
	created_at                      *time.Time
	search_blocked_until            *time.Time
	search_block_reason             *string
	search_blocked_level            *int
	addsearch_blocked_level         *int
	account_blocked_until           *time.Time
	account_block_reason            *string
	account_blocked_level           *int
	addaccount_blocked_level        *int
	clearedFields                   map[string]struct{}
	statistics                      map[int]struct{}
	removedstatistics               map[int]struct{}
	clearedstatistics               bool
	friends                         map[int]struct{}
	removedfriends                  map[int]struct{}
	clearedfriends                  bool
	sent_friend_requests            map[int]struct{}
	removedsent_friend_requests     map[int]struct{}
	clearedsent_friend_requests     bool
	received_friend_requests        map[int]struct{}
	removedreceived_friend_requests map[int]struct{}
	clearedreceived_friend_requests bool
	items                           map[int]struct{}
	removeditems                    map[int]struct{}
	cleareditems                    bool
	current_item                    *int
	clearedcurrent_item             bool
	current_match                   *int
	clearedcurrent_match            bool
	balance                         *int
	clearedbalance                  bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetHardwareID sets the "hardware_id" field.
func (m *UserMutation) SetHardwareID(s string) {
	m.hardware_id = &s
}

// HardwareID returns the value of the "hardware_id" field in the mutation.
func (m *UserMutation) HardwareID() (r string, exists bool) {
	v := m.hardware_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareID returns the old "hardware_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHardwareID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareID: %w", err)
	}
	return oldValue.HardwareID, nil
}

// ClearHardwareID clears the value of the "hardware_id" field.
func (m *UserMutation) ClearHardwareID() {
	m.hardware_id = nil
	m.clearedFields[user.FieldHardwareID] = struct{}{}
}

// HardwareIDCleared returns if the "hardware_id" field was cleared in this mutation.
func (m *UserMutation) HardwareIDCleared() bool {
	_, ok := m.clearedFields[user.FieldHardwareID]
	return ok
}

// ResetHardwareID resets all changes to the "hardware_id" field.
func (m *UserMutation) ResetHardwareID() {
	m.hardware_id = nil
	delete(m.clearedFields, user.FieldHardwareID)
}

// SetAccessLevel sets the "access_level" field.
func (m *UserMutation) SetAccessLevel(all access_level.AccessLevel) {
	m.access_level = &all
}

// AccessLevel returns the value of the "access_level" field in the mutation.
func (m *UserMutation) AccessLevel() (r access_level.AccessLevel, exists bool) {
	v := m.access_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessLevel returns the old "access_level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccessLevel(ctx context.Context) (v access_level.AccessLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessLevel: %w", err)
	}
	return oldValue.AccessLevel, nil
}

// ResetAccessLevel resets all changes to the "access_level" field.
func (m *UserMutation) ResetAccessLevel() {
	m.access_level = nil
}

// SetGenshinUID sets the "genshin_uid" field.
func (m *UserMutation) SetGenshinUID(s string) {
	m.genshin_uid = &s
}

// GenshinUID returns the value of the "genshin_uid" field in the mutation.
func (m *UserMutation) GenshinUID() (r string, exists bool) {
	v := m.genshin_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldGenshinUID returns the old "genshin_uid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGenshinUID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenshinUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenshinUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenshinUID: %w", err)
	}
	return oldValue.GenshinUID, nil
}

// ClearGenshinUID clears the value of the "genshin_uid" field.
func (m *UserMutation) ClearGenshinUID() {
	m.genshin_uid = nil
	m.clearedFields[user.FieldGenshinUID] = struct{}{}
}

// GenshinUIDCleared returns if the "genshin_uid" field was cleared in this mutation.
func (m *UserMutation) GenshinUIDCleared() bool {
	_, ok := m.clearedFields[user.FieldGenshinUID]
	return ok
}

// ResetGenshinUID resets all changes to the "genshin_uid" field.
func (m *UserMutation) ResetGenshinUID() {
	m.genshin_uid = nil
	delete(m.clearedFields, user.FieldGenshinUID)
}

// SetHoyolabLogin sets the "hoyolab_login" field.
func (m *UserMutation) SetHoyolabLogin(s string) {
	m.hoyolab_login = &s
}

// HoyolabLogin returns the value of the "hoyolab_login" field in the mutation.
func (m *UserMutation) HoyolabLogin() (r string, exists bool) {
	v := m.hoyolab_login
	if v == nil {
		return
	}
	return *v, true
}

// OldHoyolabLogin returns the old "hoyolab_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHoyolabLogin(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHoyolabLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHoyolabLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHoyolabLogin: %w", err)
	}
	return oldValue.HoyolabLogin, nil
}

// ClearHoyolabLogin clears the value of the "hoyolab_login" field.
func (m *UserMutation) ClearHoyolabLogin() {
	m.hoyolab_login = nil
	m.clearedFields[user.FieldHoyolabLogin] = struct{}{}
}

// HoyolabLoginCleared returns if the "hoyolab_login" field was cleared in this mutation.
func (m *UserMutation) HoyolabLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldHoyolabLogin]
	return ok
}

// ResetHoyolabLogin resets all changes to the "hoyolab_login" field.
func (m *UserMutation) ResetHoyolabLogin() {
	m.hoyolab_login = nil
	delete(m.clearedFields, user.FieldHoyolabLogin)
}

// SetCurrentMatchID sets the "current_match_id" field.
func (m *UserMutation) SetCurrentMatchID(i int) {
	m.current_match = &i
}

// CurrentMatchID returns the value of the "current_match_id" field in the mutation.
func (m *UserMutation) CurrentMatchID() (r int, exists bool) {
	v := m.current_match
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentMatchID returns the old "current_match_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrentMatchID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentMatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentMatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentMatchID: %w", err)
	}
	return oldValue.CurrentMatchID, nil
}

// ClearCurrentMatchID clears the value of the "current_match_id" field.
func (m *UserMutation) ClearCurrentMatchID() {
	m.current_match = nil
	m.clearedFields[user.FieldCurrentMatchID] = struct{}{}
}

// CurrentMatchIDCleared returns if the "current_match_id" field was cleared in this mutation.
func (m *UserMutation) CurrentMatchIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCurrentMatchID]
	return ok
}

// ResetCurrentMatchID resets all changes to the "current_match_id" field.
func (m *UserMutation) ResetCurrentMatchID() {
	m.current_match = nil
	delete(m.clearedFields, user.FieldCurrentMatchID)
}

// SetCurrentItemInProfileID sets the "current_item_in_profile_id" field.
func (m *UserMutation) SetCurrentItemInProfileID(i int) {
	m.current_item = &i
}

// CurrentItemInProfileID returns the value of the "current_item_in_profile_id" field in the mutation.
func (m *UserMutation) CurrentItemInProfileID() (r int, exists bool) {
	v := m.current_item
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentItemInProfileID returns the old "current_item_in_profile_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrentItemInProfileID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentItemInProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentItemInProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentItemInProfileID: %w", err)
	}
	return oldValue.CurrentItemInProfileID, nil
}

// ClearCurrentItemInProfileID clears the value of the "current_item_in_profile_id" field.
func (m *UserMutation) ClearCurrentItemInProfileID() {
	m.current_item = nil
	m.clearedFields[user.FieldCurrentItemInProfileID] = struct{}{}
}

// CurrentItemInProfileIDCleared returns if the "current_item_in_profile_id" field was cleared in this mutation.
func (m *UserMutation) CurrentItemInProfileIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCurrentItemInProfileID]
	return ok
}

// ResetCurrentItemInProfileID resets all changes to the "current_item_in_profile_id" field.
func (m *UserMutation) ResetCurrentItemInProfileID() {
	m.current_item = nil
	delete(m.clearedFields, user.FieldCurrentItemInProfileID)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *UserMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *UserMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatarURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *UserMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[user.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *UserMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *UserMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, user.FieldAvatarURL)
}

// SetInvitesEnabled sets the "invites_enabled" field.
func (m *UserMutation) SetInvitesEnabled(b bool) {
	m.invites_enabled = &b
}

// InvitesEnabled returns the value of the "invites_enabled" field in the mutation.
func (m *UserMutation) InvitesEnabled() (r bool, exists bool) {
	v := m.invites_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitesEnabled returns the old "invites_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldInvitesEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitesEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitesEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitesEnabled: %w", err)
	}
	return oldValue.InvitesEnabled, nil
}

// ResetInvitesEnabled resets all changes to the "invites_enabled" field.
func (m *UserMutation) ResetInvitesEnabled() {
	m.invites_enabled = nil
}

// SetLoginAt sets the "login_at" field.
func (m *UserMutation) SetLoginAt(t time.Time) {
	m.login_at = &t
}

// LoginAt returns the value of the "login_at" field in the mutation.
func (m *UserMutation) LoginAt() (r time.Time, exists bool) {
	v := m.login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginAt returns the old "login_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginAt: %w", err)
	}
	return oldValue.LoginAt, nil
}

// ResetLoginAt resets all changes to the "login_at" field.
func (m *UserMutation) ResetLoginAt() {
	m.login_at = nil
}

// SetLoginStreak sets the "login_streak" field.
func (m *UserMutation) SetLoginStreak(i int) {
	m.login_streak = &i
	m.addlogin_streak = nil
}

// LoginStreak returns the value of the "login_streak" field in the mutation.
func (m *UserMutation) LoginStreak() (r int, exists bool) {
	v := m.login_streak
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginStreak returns the old "login_streak" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLoginStreak(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginStreak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginStreak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginStreak: %w", err)
	}
	return oldValue.LoginStreak, nil
}

// AddLoginStreak adds i to the "login_streak" field.
func (m *UserMutation) AddLoginStreak(i int) {
	if m.addlogin_streak != nil {
		*m.addlogin_streak += i
	} else {
		m.addlogin_streak = &i
	}
}

// AddedLoginStreak returns the value that was added to the "login_streak" field in this mutation.
func (m *UserMutation) AddedLoginStreak() (r int, exists bool) {
	v := m.addlogin_streak
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoginStreak resets all changes to the "login_streak" field.
func (m *UserMutation) ResetLoginStreak() {
	m.login_streak = nil
	m.addlogin_streak = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetSearchBlockedUntil sets the "search_blocked_until" field.
func (m *UserMutation) SetSearchBlockedUntil(t time.Time) {
	m.search_blocked_until = &t
}

// SearchBlockedUntil returns the value of the "search_blocked_until" field in the mutation.
func (m *UserMutation) SearchBlockedUntil() (r time.Time, exists bool) {
	v := m.search_blocked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchBlockedUntil returns the old "search_blocked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSearchBlockedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchBlockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchBlockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchBlockedUntil: %w", err)
	}
	return oldValue.SearchBlockedUntil, nil
}

// ClearSearchBlockedUntil clears the value of the "search_blocked_until" field.
func (m *UserMutation) ClearSearchBlockedUntil() {
	m.search_blocked_until = nil
	m.clearedFields[user.FieldSearchBlockedUntil] = struct{}{}
}

// SearchBlockedUntilCleared returns if the "search_blocked_until" field was cleared in this mutation.
func (m *UserMutation) SearchBlockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldSearchBlockedUntil]
	return ok
}

// ResetSearchBlockedUntil resets all changes to the "search_blocked_until" field.
func (m *UserMutation) ResetSearchBlockedUntil() {
	m.search_blocked_until = nil
	delete(m.clearedFields, user.FieldSearchBlockedUntil)
}

// SetSearchBlockReason sets the "search_block_reason" field.
func (m *UserMutation) SetSearchBlockReason(s string) {
	m.search_block_reason = &s
}

// SearchBlockReason returns the value of the "search_block_reason" field in the mutation.
func (m *UserMutation) SearchBlockReason() (r string, exists bool) {
	v := m.search_block_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchBlockReason returns the old "search_block_reason" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSearchBlockReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchBlockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchBlockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchBlockReason: %w", err)
	}
	return oldValue.SearchBlockReason, nil
}

// ClearSearchBlockReason clears the value of the "search_block_reason" field.
func (m *UserMutation) ClearSearchBlockReason() {
	m.search_block_reason = nil
	m.clearedFields[user.FieldSearchBlockReason] = struct{}{}
}

// SearchBlockReasonCleared returns if the "search_block_reason" field was cleared in this mutation.
func (m *UserMutation) SearchBlockReasonCleared() bool {
	_, ok := m.clearedFields[user.FieldSearchBlockReason]
	return ok
}

// ResetSearchBlockReason resets all changes to the "search_block_reason" field.
func (m *UserMutation) ResetSearchBlockReason() {
	m.search_block_reason = nil
	delete(m.clearedFields, user.FieldSearchBlockReason)
}

// SetSearchBlockedLevel sets the "search_blocked_level" field.
func (m *UserMutation) SetSearchBlockedLevel(i int) {
	m.search_blocked_level = &i
	m.addsearch_blocked_level = nil
}

// SearchBlockedLevel returns the value of the "search_blocked_level" field in the mutation.
func (m *UserMutation) SearchBlockedLevel() (r int, exists bool) {
	v := m.search_blocked_level
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchBlockedLevel returns the old "search_blocked_level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSearchBlockedLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchBlockedLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchBlockedLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchBlockedLevel: %w", err)
	}
	return oldValue.SearchBlockedLevel, nil
}

// AddSearchBlockedLevel adds i to the "search_blocked_level" field.
func (m *UserMutation) AddSearchBlockedLevel(i int) {
	if m.addsearch_blocked_level != nil {
		*m.addsearch_blocked_level += i
	} else {
		m.addsearch_blocked_level = &i
	}
}

// AddedSearchBlockedLevel returns the value that was added to the "search_blocked_level" field in this mutation.
func (m *UserMutation) AddedSearchBlockedLevel() (r int, exists bool) {
	v := m.addsearch_blocked_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetSearchBlockedLevel resets all changes to the "search_blocked_level" field.
func (m *UserMutation) ResetSearchBlockedLevel() {
	m.search_blocked_level = nil
	m.addsearch_blocked_level = nil
}

// SetAccountBlockedUntil sets the "account_blocked_until" field.
func (m *UserMutation) SetAccountBlockedUntil(t time.Time) {
	m.account_blocked_until = &t
}

// AccountBlockedUntil returns the value of the "account_blocked_until" field in the mutation.
func (m *UserMutation) AccountBlockedUntil() (r time.Time, exists bool) {
	v := m.account_blocked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountBlockedUntil returns the old "account_blocked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountBlockedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountBlockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountBlockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountBlockedUntil: %w", err)
	}
	return oldValue.AccountBlockedUntil, nil
}

// ClearAccountBlockedUntil clears the value of the "account_blocked_until" field.
func (m *UserMutation) ClearAccountBlockedUntil() {
	m.account_blocked_until = nil
	m.clearedFields[user.FieldAccountBlockedUntil] = struct{}{}
}

// AccountBlockedUntilCleared returns if the "account_blocked_until" field was cleared in this mutation.
func (m *UserMutation) AccountBlockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldAccountBlockedUntil]
	return ok
}

// ResetAccountBlockedUntil resets all changes to the "account_blocked_until" field.
func (m *UserMutation) ResetAccountBlockedUntil() {
	m.account_blocked_until = nil
	delete(m.clearedFields, user.FieldAccountBlockedUntil)
}

// SetAccountBlockReason sets the "account_block_reason" field.
func (m *UserMutation) SetAccountBlockReason(s string) {
	m.account_block_reason = &s
}

// AccountBlockReason returns the value of the "account_block_reason" field in the mutation.
func (m *UserMutation) AccountBlockReason() (r string, exists bool) {
	v := m.account_block_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountBlockReason returns the old "account_block_reason" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountBlockReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountBlockReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountBlockReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountBlockReason: %w", err)
	}
	return oldValue.AccountBlockReason, nil
}

// ClearAccountBlockReason clears the value of the "account_block_reason" field.
func (m *UserMutation) ClearAccountBlockReason() {
	m.account_block_reason = nil
	m.clearedFields[user.FieldAccountBlockReason] = struct{}{}
}

// AccountBlockReasonCleared returns if the "account_block_reason" field was cleared in this mutation.
func (m *UserMutation) AccountBlockReasonCleared() bool {
	_, ok := m.clearedFields[user.FieldAccountBlockReason]
	return ok
}

// ResetAccountBlockReason resets all changes to the "account_block_reason" field.
func (m *UserMutation) ResetAccountBlockReason() {
	m.account_block_reason = nil
	delete(m.clearedFields, user.FieldAccountBlockReason)
}

// SetAccountBlockedLevel sets the "account_blocked_level" field.
func (m *UserMutation) SetAccountBlockedLevel(i int) {
	m.account_blocked_level = &i
	m.addaccount_blocked_level = nil
}

// AccountBlockedLevel returns the value of the "account_blocked_level" field in the mutation.
func (m *UserMutation) AccountBlockedLevel() (r int, exists bool) {
	v := m.account_blocked_level
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountBlockedLevel returns the old "account_blocked_level" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountBlockedLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountBlockedLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountBlockedLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountBlockedLevel: %w", err)
	}
	return oldValue.AccountBlockedLevel, nil
}

// AddAccountBlockedLevel adds i to the "account_blocked_level" field.
func (m *UserMutation) AddAccountBlockedLevel(i int) {
	if m.addaccount_blocked_level != nil {
		*m.addaccount_blocked_level += i
	} else {
		m.addaccount_blocked_level = &i
	}
}

// AddedAccountBlockedLevel returns the value that was added to the "account_blocked_level" field in this mutation.
func (m *UserMutation) AddedAccountBlockedLevel() (r int, exists bool) {
	v := m.addaccount_blocked_level
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountBlockedLevel resets all changes to the "account_blocked_level" field.
func (m *UserMutation) ResetAccountBlockedLevel() {
	m.account_blocked_level = nil
	m.addaccount_blocked_level = nil
}

// AddStatisticIDs adds the "statistics" edge to the Statistic entity by ids.
func (m *UserMutation) AddStatisticIDs(ids ...int) {
	if m.statistics == nil {
		m.statistics = make(map[int]struct{})
	}
	for i := range ids {
		m.statistics[ids[i]] = struct{}{}
	}
}

// ClearStatistics clears the "statistics" edge to the Statistic entity.
func (m *UserMutation) ClearStatistics() {
	m.clearedstatistics = true
}

// StatisticsCleared reports if the "statistics" edge to the Statistic entity was cleared.
func (m *UserMutation) StatisticsCleared() bool {
	return m.clearedstatistics
}

// RemoveStatisticIDs removes the "statistics" edge to the Statistic entity by IDs.
func (m *UserMutation) RemoveStatisticIDs(ids ...int) {
	if m.removedstatistics == nil {
		m.removedstatistics = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.statistics, ids[i])
		m.removedstatistics[ids[i]] = struct{}{}
	}
}

// RemovedStatistics returns the removed IDs of the "statistics" edge to the Statistic entity.
func (m *UserMutation) RemovedStatisticsIDs() (ids []int) {
	for id := range m.removedstatistics {
		ids = append(ids, id)
	}
	return
}

// StatisticsIDs returns the "statistics" edge IDs in the mutation.
func (m *UserMutation) StatisticsIDs() (ids []int) {
	for id := range m.statistics {
		ids = append(ids, id)
	}
	return
}

// ResetStatistics resets all changes to the "statistics" edge.
func (m *UserMutation) ResetStatistics() {
	m.statistics = nil
	m.clearedstatistics = false
	m.removedstatistics = nil
}

// AddFriendIDs adds the "friends" edge to the User entity by ids.
func (m *UserMutation) AddFriendIDs(ids ...int) {
	if m.friends == nil {
		m.friends = make(map[int]struct{})
	}
	for i := range ids {
		m.friends[ids[i]] = struct{}{}
	}
}

// ClearFriends clears the "friends" edge to the User entity.
func (m *UserMutation) ClearFriends() {
	m.clearedfriends = true
}

// FriendsCleared reports if the "friends" edge to the User entity was cleared.
func (m *UserMutation) FriendsCleared() bool {
	return m.clearedfriends
}

// RemoveFriendIDs removes the "friends" edge to the User entity by IDs.
func (m *UserMutation) RemoveFriendIDs(ids ...int) {
	if m.removedfriends == nil {
		m.removedfriends = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.friends, ids[i])
		m.removedfriends[ids[i]] = struct{}{}
	}
}

// RemovedFriends returns the removed IDs of the "friends" edge to the User entity.
func (m *UserMutation) RemovedFriendsIDs() (ids []int) {
	for id := range m.removedfriends {
		ids = append(ids, id)
	}
	return
}

// FriendsIDs returns the "friends" edge IDs in the mutation.
func (m *UserMutation) FriendsIDs() (ids []int) {
	for id := range m.friends {
		ids = append(ids, id)
	}
	return
}

// ResetFriends resets all changes to the "friends" edge.
func (m *UserMutation) ResetFriends() {
	m.friends = nil
	m.clearedfriends = false
	m.removedfriends = nil
}

// AddSentFriendRequestIDs adds the "sent_friend_requests" edge to the FriendRequest entity by ids.
func (m *UserMutation) AddSentFriendRequestIDs(ids ...int) {
	if m.sent_friend_requests == nil {
		m.sent_friend_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.sent_friend_requests[ids[i]] = struct{}{}
	}
}

// ClearSentFriendRequests clears the "sent_friend_requests" edge to the FriendRequest entity.
func (m *UserMutation) ClearSentFriendRequests() {
	m.clearedsent_friend_requests = true
}

// SentFriendRequestsCleared reports if the "sent_friend_requests" edge to the FriendRequest entity was cleared.
func (m *UserMutation) SentFriendRequestsCleared() bool {
	return m.clearedsent_friend_requests
}

// RemoveSentFriendRequestIDs removes the "sent_friend_requests" edge to the FriendRequest entity by IDs.
func (m *UserMutation) RemoveSentFriendRequestIDs(ids ...int) {
	if m.removedsent_friend_requests == nil {
		m.removedsent_friend_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sent_friend_requests, ids[i])
		m.removedsent_friend_requests[ids[i]] = struct{}{}
	}
}

// RemovedSentFriendRequests returns the removed IDs of the "sent_friend_requests" edge to the FriendRequest entity.
func (m *UserMutation) RemovedSentFriendRequestsIDs() (ids []int) {
	for id := range m.removedsent_friend_requests {
		ids = append(ids, id)
	}
	return
}

// SentFriendRequestsIDs returns the "sent_friend_requests" edge IDs in the mutation.
func (m *UserMutation) SentFriendRequestsIDs() (ids []int) {
	for id := range m.sent_friend_requests {
		ids = append(ids, id)
	}
	return
}

// ResetSentFriendRequests resets all changes to the "sent_friend_requests" edge.
func (m *UserMutation) ResetSentFriendRequests() {
	m.sent_friend_requests = nil
	m.clearedsent_friend_requests = false
	m.removedsent_friend_requests = nil
}

// AddReceivedFriendRequestIDs adds the "received_friend_requests" edge to the FriendRequest entity by ids.
func (m *UserMutation) AddReceivedFriendRequestIDs(ids ...int) {
	if m.received_friend_requests == nil {
		m.received_friend_requests = make(map[int]struct{})
	}
	for i := range ids {
		m.received_friend_requests[ids[i]] = struct{}{}
	}
}

// ClearReceivedFriendRequests clears the "received_friend_requests" edge to the FriendRequest entity.
func (m *UserMutation) ClearReceivedFriendRequests() {
	m.clearedreceived_friend_requests = true
}

// ReceivedFriendRequestsCleared reports if the "received_friend_requests" edge to the FriendRequest entity was cleared.
func (m *UserMutation) ReceivedFriendRequestsCleared() bool {
	return m.clearedreceived_friend_requests
}

// RemoveReceivedFriendRequestIDs removes the "received_friend_requests" edge to the FriendRequest entity by IDs.
func (m *UserMutation) RemoveReceivedFriendRequestIDs(ids ...int) {
	if m.removedreceived_friend_requests == nil {
		m.removedreceived_friend_requests = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.received_friend_requests, ids[i])
		m.removedreceived_friend_requests[ids[i]] = struct{}{}
	}
}

// RemovedReceivedFriendRequests returns the removed IDs of the "received_friend_requests" edge to the FriendRequest entity.
func (m *UserMutation) RemovedReceivedFriendRequestsIDs() (ids []int) {
	for id := range m.removedreceived_friend_requests {
		ids = append(ids, id)
	}
	return
}

// ReceivedFriendRequestsIDs returns the "received_friend_requests" edge IDs in the mutation.
func (m *UserMutation) ReceivedFriendRequestsIDs() (ids []int) {
	for id := range m.received_friend_requests {
		ids = append(ids, id)
	}
	return
}

// ResetReceivedFriendRequests resets all changes to the "received_friend_requests" edge.
func (m *UserMutation) ResetReceivedFriendRequests() {
	m.received_friend_requests = nil
	m.clearedreceived_friend_requests = false
	m.removedreceived_friend_requests = nil
}

// AddItemIDs adds the "items" edge to the InventoryItem entity by ids.
func (m *UserMutation) AddItemIDs(ids ...int) {
	if m.items == nil {
		m.items = make(map[int]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the InventoryItem entity.
func (m *UserMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the InventoryItem entity was cleared.
func (m *UserMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the InventoryItem entity by IDs.
func (m *UserMutation) RemoveItemIDs(ids ...int) {
	if m.removeditems == nil {
		m.removeditems = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the InventoryItem entity.
func (m *UserMutation) RemovedItemsIDs() (ids []int) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *UserMutation) ItemsIDs() (ids []int) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *UserMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// SetCurrentItemID sets the "current_item" edge to the InventoryItem entity by id.
func (m *UserMutation) SetCurrentItemID(id int) {
	m.current_item = &id
}

// ClearCurrentItem clears the "current_item" edge to the InventoryItem entity.
func (m *UserMutation) ClearCurrentItem() {
	m.clearedcurrent_item = true
	m.clearedFields[user.FieldCurrentItemInProfileID] = struct{}{}
}

// CurrentItemCleared reports if the "current_item" edge to the InventoryItem entity was cleared.
func (m *UserMutation) CurrentItemCleared() bool {
	return m.CurrentItemInProfileIDCleared() || m.clearedcurrent_item
}

// CurrentItemID returns the "current_item" edge ID in the mutation.
func (m *UserMutation) CurrentItemID() (id int, exists bool) {
	if m.current_item != nil {
		return *m.current_item, true
	}
	return
}

// CurrentItemIDs returns the "current_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrentItemID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CurrentItemIDs() (ids []int) {
	if id := m.current_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrentItem resets all changes to the "current_item" edge.
func (m *UserMutation) ResetCurrentItem() {
	m.current_item = nil
	m.clearedcurrent_item = false
}

// ClearCurrentMatch clears the "current_match" edge to the Match entity.
func (m *UserMutation) ClearCurrentMatch() {
	m.clearedcurrent_match = true
	m.clearedFields[user.FieldCurrentMatchID] = struct{}{}
}

// CurrentMatchCleared reports if the "current_match" edge to the Match entity was cleared.
func (m *UserMutation) CurrentMatchCleared() bool {
	return m.CurrentMatchIDCleared() || m.clearedcurrent_match
}

// CurrentMatchIDs returns the "current_match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrentMatchID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CurrentMatchIDs() (ids []int) {
	if id := m.current_match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrentMatch resets all changes to the "current_match" edge.
func (m *UserMutation) ResetCurrentMatch() {
	m.current_match = nil
	m.clearedcurrent_match = false
}

// SetBalanceID sets the "balance" edge to the UserBalance entity by id.
func (m *UserMutation) SetBalanceID(id int) {
	m.balance = &id
}

// ClearBalance clears the "balance" edge to the UserBalance entity.
func (m *UserMutation) ClearBalance() {
	m.clearedbalance = true
}

// BalanceCleared reports if the "balance" edge to the UserBalance entity was cleared.
func (m *UserMutation) BalanceCleared() bool {
	return m.clearedbalance
}

// BalanceID returns the "balance" edge ID in the mutation.
func (m *UserMutation) BalanceID() (id int, exists bool) {
	if m.balance != nil {
		return *m.balance, true
	}
	return
}

// BalanceIDs returns the "balance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BalanceID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BalanceIDs() (ids []int) {
	if id := m.balance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBalance resets all changes to the "balance" edge.
func (m *UserMutation) ResetBalance() {
	m.balance = nil
	m.clearedbalance = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.hardware_id != nil {
		fields = append(fields, user.FieldHardwareID)
	}
	if m.access_level != nil {
		fields = append(fields, user.FieldAccessLevel)
	}
	if m.genshin_uid != nil {
		fields = append(fields, user.FieldGenshinUID)
	}
	if m.hoyolab_login != nil {
		fields = append(fields, user.FieldHoyolabLogin)
	}
	if m.current_match != nil {
		fields = append(fields, user.FieldCurrentMatchID)
	}
	if m.current_item != nil {
		fields = append(fields, user.FieldCurrentItemInProfileID)
	}
	if m.avatar_url != nil {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.invites_enabled != nil {
		fields = append(fields, user.FieldInvitesEnabled)
	}
	if m.login_at != nil {
		fields = append(fields, user.FieldLoginAt)
	}
	if m.login_streak != nil {
		fields = append(fields, user.FieldLoginStreak)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.search_blocked_until != nil {
		fields = append(fields, user.FieldSearchBlockedUntil)
	}
	if m.search_block_reason != nil {
		fields = append(fields, user.FieldSearchBlockReason)
	}
	if m.search_blocked_level != nil {
		fields = append(fields, user.FieldSearchBlockedLevel)
	}
	if m.account_blocked_until != nil {
		fields = append(fields, user.FieldAccountBlockedUntil)
	}
	if m.account_block_reason != nil {
		fields = append(fields, user.FieldAccountBlockReason)
	}
	if m.account_blocked_level != nil {
		fields = append(fields, user.FieldAccountBlockedLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldHardwareID:
		return m.HardwareID()
	case user.FieldAccessLevel:
		return m.AccessLevel()
	case user.FieldGenshinUID:
		return m.GenshinUID()
	case user.FieldHoyolabLogin:
		return m.HoyolabLogin()
	case user.FieldCurrentMatchID:
		return m.CurrentMatchID()
	case user.FieldCurrentItemInProfileID:
		return m.CurrentItemInProfileID()
	case user.FieldAvatarURL:
		return m.AvatarURL()
	case user.FieldInvitesEnabled:
		return m.InvitesEnabled()
	case user.FieldLoginAt:
		return m.LoginAt()
	case user.FieldLoginStreak:
		return m.LoginStreak()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldSearchBlockedUntil:
		return m.SearchBlockedUntil()
	case user.FieldSearchBlockReason:
		return m.SearchBlockReason()
	case user.FieldSearchBlockedLevel:
		return m.SearchBlockedLevel()
	case user.FieldAccountBlockedUntil:
		return m.AccountBlockedUntil()
	case user.FieldAccountBlockReason:
		return m.AccountBlockReason()
	case user.FieldAccountBlockedLevel:
		return m.AccountBlockedLevel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldHardwareID:
		return m.OldHardwareID(ctx)
	case user.FieldAccessLevel:
		return m.OldAccessLevel(ctx)
	case user.FieldGenshinUID:
		return m.OldGenshinUID(ctx)
	case user.FieldHoyolabLogin:
		return m.OldHoyolabLogin(ctx)
	case user.FieldCurrentMatchID:
		return m.OldCurrentMatchID(ctx)
	case user.FieldCurrentItemInProfileID:
		return m.OldCurrentItemInProfileID(ctx)
	case user.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case user.FieldInvitesEnabled:
		return m.OldInvitesEnabled(ctx)
	case user.FieldLoginAt:
		return m.OldLoginAt(ctx)
	case user.FieldLoginStreak:
		return m.OldLoginStreak(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldSearchBlockedUntil:
		return m.OldSearchBlockedUntil(ctx)
	case user.FieldSearchBlockReason:
		return m.OldSearchBlockReason(ctx)
	case user.FieldSearchBlockedLevel:
		return m.OldSearchBlockedLevel(ctx)
	case user.FieldAccountBlockedUntil:
		return m.OldAccountBlockedUntil(ctx)
	case user.FieldAccountBlockReason:
		return m.OldAccountBlockReason(ctx)
	case user.FieldAccountBlockedLevel:
		return m.OldAccountBlockedLevel(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareID(v)
		return nil
	case user.FieldAccessLevel:
		v, ok := value.(access_level.AccessLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessLevel(v)
		return nil
	case user.FieldGenshinUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenshinUID(v)
		return nil
	case user.FieldHoyolabLogin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHoyolabLogin(v)
		return nil
	case user.FieldCurrentMatchID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentMatchID(v)
		return nil
	case user.FieldCurrentItemInProfileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentItemInProfileID(v)
		return nil
	case user.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case user.FieldInvitesEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitesEnabled(v)
		return nil
	case user.FieldLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginAt(v)
		return nil
	case user.FieldLoginStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginStreak(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldSearchBlockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchBlockedUntil(v)
		return nil
	case user.FieldSearchBlockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchBlockReason(v)
		return nil
	case user.FieldSearchBlockedLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchBlockedLevel(v)
		return nil
	case user.FieldAccountBlockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountBlockedUntil(v)
		return nil
	case user.FieldAccountBlockReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountBlockReason(v)
		return nil
	case user.FieldAccountBlockedLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountBlockedLevel(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addlogin_streak != nil {
		fields = append(fields, user.FieldLoginStreak)
	}
	if m.addsearch_blocked_level != nil {
		fields = append(fields, user.FieldSearchBlockedLevel)
	}
	if m.addaccount_blocked_level != nil {
		fields = append(fields, user.FieldAccountBlockedLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldLoginStreak:
		return m.AddedLoginStreak()
	case user.FieldSearchBlockedLevel:
		return m.AddedSearchBlockedLevel()
	case user.FieldAccountBlockedLevel:
		return m.AddedAccountBlockedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldLoginStreak:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoginStreak(v)
		return nil
	case user.FieldSearchBlockedLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSearchBlockedLevel(v)
		return nil
	case user.FieldAccountBlockedLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountBlockedLevel(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldHardwareID) {
		fields = append(fields, user.FieldHardwareID)
	}
	if m.FieldCleared(user.FieldGenshinUID) {
		fields = append(fields, user.FieldGenshinUID)
	}
	if m.FieldCleared(user.FieldHoyolabLogin) {
		fields = append(fields, user.FieldHoyolabLogin)
	}
	if m.FieldCleared(user.FieldCurrentMatchID) {
		fields = append(fields, user.FieldCurrentMatchID)
	}
	if m.FieldCleared(user.FieldCurrentItemInProfileID) {
		fields = append(fields, user.FieldCurrentItemInProfileID)
	}
	if m.FieldCleared(user.FieldAvatarURL) {
		fields = append(fields, user.FieldAvatarURL)
	}
	if m.FieldCleared(user.FieldSearchBlockedUntil) {
		fields = append(fields, user.FieldSearchBlockedUntil)
	}
	if m.FieldCleared(user.FieldSearchBlockReason) {
		fields = append(fields, user.FieldSearchBlockReason)
	}
	if m.FieldCleared(user.FieldAccountBlockedUntil) {
		fields = append(fields, user.FieldAccountBlockedUntil)
	}
	if m.FieldCleared(user.FieldAccountBlockReason) {
		fields = append(fields, user.FieldAccountBlockReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldHardwareID:
		m.ClearHardwareID()
		return nil
	case user.FieldGenshinUID:
		m.ClearGenshinUID()
		return nil
	case user.FieldHoyolabLogin:
		m.ClearHoyolabLogin()
		return nil
	case user.FieldCurrentMatchID:
		m.ClearCurrentMatchID()
		return nil
	case user.FieldCurrentItemInProfileID:
		m.ClearCurrentItemInProfileID()
		return nil
	case user.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	case user.FieldSearchBlockedUntil:
		m.ClearSearchBlockedUntil()
		return nil
	case user.FieldSearchBlockReason:
		m.ClearSearchBlockReason()
		return nil
	case user.FieldAccountBlockedUntil:
		m.ClearAccountBlockedUntil()
		return nil
	case user.FieldAccountBlockReason:
		m.ClearAccountBlockReason()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldHardwareID:
		m.ResetHardwareID()
		return nil
	case user.FieldAccessLevel:
		m.ResetAccessLevel()
		return nil
	case user.FieldGenshinUID:
		m.ResetGenshinUID()
		return nil
	case user.FieldHoyolabLogin:
		m.ResetHoyolabLogin()
		return nil
	case user.FieldCurrentMatchID:
		m.ResetCurrentMatchID()
		return nil
	case user.FieldCurrentItemInProfileID:
		m.ResetCurrentItemInProfileID()
		return nil
	case user.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case user.FieldInvitesEnabled:
		m.ResetInvitesEnabled()
		return nil
	case user.FieldLoginAt:
		m.ResetLoginAt()
		return nil
	case user.FieldLoginStreak:
		m.ResetLoginStreak()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldSearchBlockedUntil:
		m.ResetSearchBlockedUntil()
		return nil
	case user.FieldSearchBlockReason:
		m.ResetSearchBlockReason()
		return nil
	case user.FieldSearchBlockedLevel:
		m.ResetSearchBlockedLevel()
		return nil
	case user.FieldAccountBlockedUntil:
		m.ResetAccountBlockedUntil()
		return nil
	case user.FieldAccountBlockReason:
		m.ResetAccountBlockReason()
		return nil
	case user.FieldAccountBlockedLevel:
		m.ResetAccountBlockedLevel()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.statistics != nil {
		edges = append(edges, user.EdgeStatistics)
	}
	if m.friends != nil {
		edges = append(edges, user.EdgeFriends)
	}
	if m.sent_friend_requests != nil {
		edges = append(edges, user.EdgeSentFriendRequests)
	}
	if m.received_friend_requests != nil {
		edges = append(edges, user.EdgeReceivedFriendRequests)
	}
	if m.items != nil {
		edges = append(edges, user.EdgeItems)
	}
	if m.current_item != nil {
		edges = append(edges, user.EdgeCurrentItem)
	}
	if m.current_match != nil {
		edges = append(edges, user.EdgeCurrentMatch)
	}
	if m.balance != nil {
		edges = append(edges, user.EdgeBalance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStatistics:
		ids := make([]ent.Value, 0, len(m.statistics))
		for id := range m.statistics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.friends))
		for id := range m.friends {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentFriendRequests:
		ids := make([]ent.Value, 0, len(m.sent_friend_requests))
		for id := range m.sent_friend_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedFriendRequests:
		ids := make([]ent.Value, 0, len(m.received_friend_requests))
		for id := range m.received_friend_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCurrentItem:
		if id := m.current_item; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCurrentMatch:
		if id := m.current_match; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeBalance:
		if id := m.balance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedstatistics != nil {
		edges = append(edges, user.EdgeStatistics)
	}
	if m.removedfriends != nil {
		edges = append(edges, user.EdgeFriends)
	}
	if m.removedsent_friend_requests != nil {
		edges = append(edges, user.EdgeSentFriendRequests)
	}
	if m.removedreceived_friend_requests != nil {
		edges = append(edges, user.EdgeReceivedFriendRequests)
	}
	if m.removeditems != nil {
		edges = append(edges, user.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStatistics:
		ids := make([]ent.Value, 0, len(m.removedstatistics))
		for id := range m.removedstatistics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.removedfriends))
		for id := range m.removedfriends {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentFriendRequests:
		ids := make([]ent.Value, 0, len(m.removedsent_friend_requests))
		for id := range m.removedsent_friend_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedFriendRequests:
		ids := make([]ent.Value, 0, len(m.removedreceived_friend_requests))
		for id := range m.removedreceived_friend_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedstatistics {
		edges = append(edges, user.EdgeStatistics)
	}
	if m.clearedfriends {
		edges = append(edges, user.EdgeFriends)
	}
	if m.clearedsent_friend_requests {
		edges = append(edges, user.EdgeSentFriendRequests)
	}
	if m.clearedreceived_friend_requests {
		edges = append(edges, user.EdgeReceivedFriendRequests)
	}
	if m.cleareditems {
		edges = append(edges, user.EdgeItems)
	}
	if m.clearedcurrent_item {
		edges = append(edges, user.EdgeCurrentItem)
	}
	if m.clearedcurrent_match {
		edges = append(edges, user.EdgeCurrentMatch)
	}
	if m.clearedbalance {
		edges = append(edges, user.EdgeBalance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStatistics:
		return m.clearedstatistics
	case user.EdgeFriends:
		return m.clearedfriends
	case user.EdgeSentFriendRequests:
		return m.clearedsent_friend_requests
	case user.EdgeReceivedFriendRequests:
		return m.clearedreceived_friend_requests
	case user.EdgeItems:
		return m.cleareditems
	case user.EdgeCurrentItem:
		return m.clearedcurrent_item
	case user.EdgeCurrentMatch:
		return m.clearedcurrent_match
	case user.EdgeBalance:
		return m.clearedbalance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCurrentItem:
		m.ClearCurrentItem()
		return nil
	case user.EdgeCurrentMatch:
		m.ClearCurrentMatch()
		return nil
	case user.EdgeBalance:
		m.ClearBalance()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStatistics:
		m.ResetStatistics()
		return nil
	case user.EdgeFriends:
		m.ResetFriends()
		return nil
	case user.EdgeSentFriendRequests:
		m.ResetSentFriendRequests()
		return nil
	case user.EdgeReceivedFriendRequests:
		m.ResetReceivedFriendRequests()
		return nil
	case user.EdgeItems:
		m.ResetItems()
		return nil
	case user.EdgeCurrentItem:
		m.ResetCurrentItem()
		return nil
	case user.EdgeCurrentMatch:
		m.ResetCurrentMatch()
		return nil
	case user.EdgeBalance:
		m.ResetBalance()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserBalanceMutation represents an operation that mutates the UserBalance nodes in the graph.
type UserBalanceMutation struct {
	config
	op            Op
	typ           string
	id            *int
	coins         *float64
	addcoins      *float64
	last_updated  *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserBalance, error)
	predicates    []predicate.UserBalance
}

var _ ent.Mutation = (*UserBalanceMutation)(nil)

// userbalanceOption allows management of the mutation configuration using functional options.
type userbalanceOption func(*UserBalanceMutation)

// newUserBalanceMutation creates new mutation for the UserBalance entity.
func newUserBalanceMutation(c config, op Op, opts ...userbalanceOption) *UserBalanceMutation {
	m := &UserBalanceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserBalance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserBalanceID sets the ID field of the mutation.
func withUserBalanceID(id int) userbalanceOption {
	return func(m *UserBalanceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserBalance
		)
		m.oldValue = func(ctx context.Context) (*UserBalance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserBalance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserBalance sets the old UserBalance of the mutation.
func withUserBalance(node *UserBalance) userbalanceOption {
	return func(m *UserBalanceMutation) {
		m.oldValue = func(context.Context) (*UserBalance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserBalanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserBalanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserBalance entities.
func (m *UserBalanceMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserBalanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserBalanceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserBalance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserBalanceMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserBalanceMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserBalance entity.
// If the UserBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserBalanceMutation) ResetUserID() {
	m.user = nil
}

// SetCoins sets the "coins" field.
func (m *UserBalanceMutation) SetCoins(f float64) {
	m.coins = &f
	m.addcoins = nil
}

// Coins returns the value of the "coins" field in the mutation.
func (m *UserBalanceMutation) Coins() (r float64, exists bool) {
	v := m.coins
	if v == nil {
		return
	}
	return *v, true
}

// OldCoins returns the old "coins" field's value of the UserBalance entity.
// If the UserBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceMutation) OldCoins(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoins: %w", err)
	}
	return oldValue.Coins, nil
}

// AddCoins adds f to the "coins" field.
func (m *UserBalanceMutation) AddCoins(f float64) {
	if m.addcoins != nil {
		*m.addcoins += f
	} else {
		m.addcoins = &f
	}
}

// AddedCoins returns the value that was added to the "coins" field in this mutation.
func (m *UserBalanceMutation) AddedCoins() (r float64, exists bool) {
	v := m.addcoins
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoins resets all changes to the "coins" field.
func (m *UserBalanceMutation) ResetCoins() {
	m.coins = nil
	m.addcoins = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *UserBalanceMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *UserBalanceMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the UserBalance entity.
// If the UserBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *UserBalanceMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserBalanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserBalanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserBalance entity.
// If the UserBalance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserBalanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserBalanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserBalanceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userbalance.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserBalanceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserBalanceMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserBalanceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserBalanceMutation builder.
func (m *UserBalanceMutation) Where(ps ...predicate.UserBalance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserBalanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserBalanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserBalance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserBalanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserBalanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserBalance).
func (m *UserBalanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserBalanceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, userbalance.FieldUserID)
	}
	if m.coins != nil {
		fields = append(fields, userbalance.FieldCoins)
	}
	if m.last_updated != nil {
		fields = append(fields, userbalance.FieldLastUpdated)
	}
	if m.created_at != nil {
		fields = append(fields, userbalance.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserBalanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userbalance.FieldUserID:
		return m.UserID()
	case userbalance.FieldCoins:
		return m.Coins()
	case userbalance.FieldLastUpdated:
		return m.LastUpdated()
	case userbalance.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserBalanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userbalance.FieldUserID:
		return m.OldUserID(ctx)
	case userbalance.FieldCoins:
		return m.OldCoins(ctx)
	case userbalance.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	case userbalance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserBalance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBalanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userbalance.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userbalance.FieldCoins:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoins(v)
		return nil
	case userbalance.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	case userbalance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserBalance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserBalanceMutation) AddedFields() []string {
	var fields []string
	if m.addcoins != nil {
		fields = append(fields, userbalance.FieldCoins)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserBalanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userbalance.FieldCoins:
		return m.AddedCoins()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserBalanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userbalance.FieldCoins:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoins(v)
		return nil
	}
	return fmt.Errorf("unknown UserBalance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserBalanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserBalanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserBalanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserBalance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserBalanceMutation) ResetField(name string) error {
	switch name {
	case userbalance.FieldUserID:
		m.ResetUserID()
		return nil
	case userbalance.FieldCoins:
		m.ResetCoins()
		return nil
	case userbalance.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	case userbalance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserBalance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserBalanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userbalance.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserBalanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userbalance.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserBalanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserBalanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserBalanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userbalance.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserBalanceMutation) EdgeCleared(name string) bool {
	switch name {
	case userbalance.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserBalanceMutation) ClearEdge(name string) error {
	switch name {
	case userbalance.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserBalance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserBalanceMutation) ResetEdge(name string) error {
	switch name {
	case userbalance.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserBalance edge %s", name)
}
